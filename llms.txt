This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: dist, CLAUDE.md, AGENTS.md, issues, .specstory, work
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    push.yml
    release.yml
src/
  geminpy/
    browser/
      __init__.py
      automation.py
      chrome.py
      manager.py
    core/
      __init__.py
      config.py
      constants.py
      exceptions.py
    gemini/
      __init__.py
      client.py
      executor.py
      parser.py
    utils/
      __init__.py
      logging.py
      platform.py
      storage.py
    __init__.py
    __main__.py
    api.py
    cli.py
    geminpy.py
tests/
  test_browser/
    test_automation.py
    test_chrome.py
    test_manager.py
  test_gemini/
    test_client.py
    test_executor.py
    test_parser.py
  test_utils/
    test_platform.py
    test_storage.py
  conftest.py
  test_api.py
  test_cli.py
  test_package.py
.cursorindexingignore
.cursorrules
.gitignore
.pre-commit-config.yaml
build.sh
CHANGELOG.md
LICENSE
package.toml
pyproject.toml
README.md
TODO.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="build.sh">
#!/usr/bin/env bash

npx repomix -i 'dist,CLAUDE.md,AGENTS.md,issues,.specstory,work' -o ./llms.txt .
uvx hatch clean && uvx hatch build
</file>

<file path=".github/workflows/push.yml">
name: Build & Test

on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"

      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"

  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}

      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"

      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/geminpy --cov=tests tests/

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml

  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5
</file>

<file path=".github/workflows/release.yml">
name: Release

on:
  push:
    tags: ["v*"]

permissions:
  contents: write
  id-token: write

jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/geminpy
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
</file>

<file path="src/geminpy/browser/__init__.py">
# this_file: src/geminpy/browser/__init__.py
"""Browser management and automation components."""

from geminpy.browser.automation import OAuthAutomator
from geminpy.browser.chrome import ChromeManager, ChromeTestingManager
from geminpy.browser.manager import BrowserManager

__all__ = ["BrowserManager", "ChromeManager", "ChromeTestingManager", "OAuthAutomator"]
</file>

<file path="src/geminpy/browser/chrome.py">
# this_file: src/geminpy/browser/chrome.py
"""Chrome for Testing management and process control."""

import asyncio
import subprocess
import time
from pathlib import Path

import requests
from loguru import logger

from geminpy.core.config import AppConfig, ChromeConfig
from geminpy.core.constants import CDP_VERSION_URL, BrowserID
from geminpy.core.exceptions import ChromeError, ChromeInstallationError
from geminpy.utils.storage import SettingsManager


class ChromeTestingManager:
    """Manages Chrome for Testing installation and configuration."""

    def __init__(self, config: AppConfig):
        """Initialize with app configuration."""
        self.config = config
        self.settings = SettingsManager(config.settings_dir)

    def get_stored_path(self) -> Path | None:
        """Get the stored Chrome for Testing executable path."""
        path_str = self.settings.get("chrome_testing_path")
        return Path(path_str) if path_str else None

    def set_stored_path(self, path: Path) -> None:
        """Store the Chrome for Testing executable path."""
        self.settings.set("chrome_testing_path", str(path))

    def get_stored_user(self) -> str | None:
        """Get the stored gemini CLI user email."""
        return self.settings.get("gemini_cli_user")

    def set_stored_user(self, user_email: str) -> None:
        """Store the gemini CLI user email."""
        self.settings.set("gemini_cli_user", user_email)

    def install(self) -> Path:
        """Install Chrome for Testing and return the executable path."""
        logger.debug("Installing Chrome for Testing...")

        cmd = [
            "npx",
            "-y",
            "@puppeteer/browsers",
            "install",
            "chrome@stable",
            "--platform",
            "mac",
            "--path",
            "/Applications",
            "--quiet",
        ]

        logger.debug(f"Running: {' '.join(cmd)}")
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)

        # Parse the output to find the executable path
        executable_path = None
        for line in result.stdout.strip().split("\n"):
            line = line.strip()
            if line and not line.startswith("Downloading"):
                parts = line.split(" ", 1)
                if len(parts) == 2:
                    executable_path = parts[1]
                    break

        if not executable_path:
            msg = f"Could not parse Chrome for Testing path from output: {result.stdout}"
            raise ChromeInstallationError(
                msg
            )

        path = Path(executable_path)
        if not path.exists():
            msg = f"Chrome for Testing executable not found at: {executable_path}"
            raise ChromeInstallationError(
                msg
            )

        logger.debug(f"Chrome for Testing installed at: {executable_path}")
        self.set_stored_path(path)
        return path

    def ensure_available(self) -> Path:
        """Ensure Chrome for Testing is available and return the executable path."""
        from geminpy.browser.manager import BrowserManager

        # Check if we already have the path stored
        stored_path = self.get_stored_path()
        if stored_path and stored_path.exists():
            logger.debug(f"Using existing Chrome for Testing: {stored_path}")
            return stored_path

        # Check if 'testing' browser is available in macdefaultbrowsy
        available_browsers = BrowserManager.get_available_browsers()
        if BrowserID.TESTING not in available_browsers:
            logger.debug(
                f"'{BrowserID.TESTING}' browser not found in available browsers: {available_browsers}"
            )
            logger.debug("Installing Chrome for Testing...")
            return self.install()
        logger.debug(f"'{BrowserID.TESTING}' browser found in available browsers")
        stored_path = self.get_stored_path()
        if stored_path and stored_path.exists():
            return stored_path
        logger.debug("Chrome for Testing path not found, reinstalling...")
        return self.install()


class ChromeManager:
    """Manages Chrome for Testing processes."""

    def __init__(self, config: ChromeConfig):
        """Initialize with Chrome configuration."""
        self.config = config

    def launch(self, executable_path: Path) -> subprocess.Popen:
        """Launch Chrome for Testing with CDP enabled."""
        args = [
            str(executable_path),
            f"--remote-debugging-port={self.config.debug_port}",
            f"--user-data-dir={self.config.user_data_dir}",
            "--no-first-run",
            "--no-default-browser-check",
            "--disable-popup-blocking",
            "--disable-web-security",
            "--disable-features=VizDisplayCompositor",
            "about:blank",
        ]

        logger.debug(f"exec: {' '.join(args)}")

        # Capture stderr for debugging
        stderr_file = "/tmp/gemini_chrome_stderr.log"
        with open(stderr_file, "w") as f:
            f.write(f"Chrome for Testing launch command: {' '.join(args)}\n")
            f.write("=" * 50 + "\n")

        logger.debug(f"Chrome stderr will be logged to: {stderr_file}")

        return subprocess.Popen(
            args, stdout=subprocess.DEVNULL, stderr=open(stderr_file, "a")
        )

    def is_cdp_ready(self) -> bool:
        """Check if Chrome CDP endpoint is ready."""
        try:
            response = requests.get(
                CDP_VERSION_URL.format(port=self.config.debug_port), timeout=1
            )
            return response.status_code == 200
        except requests.RequestException:
            return False

    async def wait_for_cdp(self, timeout: int = 20) -> None:
        """Wait for Chrome's CDP to be ready."""
        logger.debug("Waiting for Chrome CDP port to open...")
        start_time = time.time()
        retry_count = 0
        max_retries = 20

        while time.time() - start_time < timeout:
            retry_count += 1
            try:
                response = requests.get(
                    CDP_VERSION_URL.format(port=self.config.debug_port), timeout=1
                )
                if response.status_code == 200:
                    logger.debug(f"Chrome CDP is ready after {retry_count} attempts.")
                    return
                logger.debug(
                    f"retry {retry_count}/{max_retries} … HTTP {response.status_code}"
                )
            except requests.ConnectionError:
                logger.debug(f"retry {retry_count}/{max_retries} … connection refused")
            except requests.RequestException as e:
                logger.debug(
                    f"retry {retry_count}/{max_retries} … {type(e).__name__}: {e}"
                )

            await asyncio.sleep(1)

        error_msg = f"""
ERROR: Chrome never opened port {self.config.debug_port} after {retry_count} attempts.

Possible causes:
• Another Chrome instance was already running without --remote-debugging-port
• A firewall is blocking localhost:{self.config.debug_port}
• Chrome failed to start (check /tmp/gemini_chrome_stderr.log)

Try manually:
  curl http://localhost:{self.config.debug_port}/json/version

You should get a JSON response with 'webSocketDebuggerUrl'.
"""
        logger.error(error_msg.strip())
        msg = f"Chrome CDP did not become available after {retry_count} attempts."
        raise ChromeError(
            msg
        )
</file>

<file path="src/geminpy/core/__init__.py">
# this_file: src/geminpy/core/__init__.py
"""Core components for Geminpy."""

from geminpy.core.config import AppConfig, ChromeConfig, GeminiConfig
from geminpy.core.constants import AuthStatus, BrowserID, RateLimitIndicators
from geminpy.core.exceptions import (
    AuthenticationError,
    BrowserManagementError,
    ChromeError,
    ChromeInstallationError,
    GeminiError,
    PlatformError,
    RateLimitError,
)

__all__ = [
    "AppConfig",
    "AuthStatus",
    "AuthenticationError",
    "BrowserID",
    "BrowserManagementError",
    "ChromeConfig",
    "ChromeError",
    "ChromeInstallationError",
    "GeminiConfig",
    "GeminiError",
    "PlatformError",
    "RateLimitError",
    "RateLimitIndicators",
]
</file>

<file path="src/geminpy/core/config.py">
# this_file: src/geminpy/core/config.py
"""Configuration management for Geminpy."""

from dataclasses import dataclass, field
from pathlib import Path

from platformdirs import user_data_dir


@dataclass
class ChromeConfig:
    """Chrome for Testing configuration."""

    executable_path: Path | None = None
    debug_port: int = 9222
    user_data_dir: Path = Path("/tmp/chrome_gemini_automation")
    quit_chrome: bool = False


@dataclass
class GeminiConfig:
    """Gemini CLI configuration."""

    executable: str | Path = "gemini"
    default_model: str = "gemini-2.5-flash"
    timeout: int = 120


@dataclass
class AppConfig:
    """Main application configuration."""

    app_name: str = "com.twardoch.geminpy"
    chrome: ChromeConfig = field(default_factory=ChromeConfig)
    gemini: GeminiConfig = field(default_factory=GeminiConfig)
    user_email: str | None = None
    verbose: bool = False

    @property
    def settings_dir(self) -> Path:
        """Get the settings directory path."""
        return Path(user_data_dir(appname=self.app_name))
</file>

<file path="src/geminpy/core/constants.py">
# this_file: src/geminpy/core/constants.py
"""Constants and enums for Geminpy."""

from enum import Enum


class AuthStatus(Enum):
    """OAuth authentication status."""

    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    SUCCESS = "success"
    FAILED = "failed"


class RateLimitIndicators:
    """Patterns indicating rate limit errors."""

    PATTERNS = ["429", "Quota exceeded", "rateLimitExceeded", "RESOURCE_EXHAUSTED"]


class BrowserID:
    """Browser identifiers."""

    TESTING = "testing"


# URLs and patterns
CDP_VERSION_URL = "http://localhost:{port}/json/version"
OAUTH_SIGNIN_PATTERN = r"accounts\.google\.com/signin/oauth"
SUCCESS_PATTERN = r"developers\.google\.com/gemini-code-assist/auth/auth_success_gemini"
</file>

<file path="src/geminpy/core/exceptions.py">
# this_file: src/geminpy/core/exceptions.py
"""Custom exceptions for Geminpy."""


class GeminiError(Exception):
    """Base exception for all Geminpy errors."""


class ChromeError(GeminiError):
    """Chrome-related errors."""


class BrowserManagementError(ChromeError):
    """Browser switching/management errors."""


class ChromeInstallationError(ChromeError):
    """Chrome for Testing installation errors."""


class AuthenticationError(GeminiError):
    """OAuth authentication errors."""


class RateLimitError(GeminiError):
    """API rate limit errors."""


class PlatformError(GeminiError):
    """Platform compatibility errors."""
</file>

<file path="src/geminpy/gemini/__init__.py">
# this_file: src/geminpy/gemini/__init__.py
"""Gemini CLI integration components."""

from geminpy.gemini.client import GeminiClient
from geminpy.gemini.executor import GeminiExecutor
from geminpy.gemini.parser import ResponseParser

__all__ = ["GeminiClient", "GeminiExecutor", "ResponseParser"]
</file>

<file path="src/geminpy/gemini/client.py">
# this_file: src/geminpy/gemini/client.py
"""Main orchestrator for Gemini CLI automation."""

import asyncio
import subprocess

from loguru import logger

from geminpy.browser.automation import OAuthAutomator, UserResolver
from geminpy.browser.chrome import ChromeManager, ChromeTestingManager
from geminpy.browser.manager import BrowserManager
from geminpy.core.config import AppConfig
from geminpy.core.constants import BrowserID
from geminpy.core.exceptions import RateLimitError
from geminpy.gemini.executor import GeminiExecutor
from geminpy.gemini.parser import ResponseParser


class GeminiClient:
    """Main orchestrator for Gemini CLI automation."""

    def __init__(self, config: AppConfig):
        """Initialize with app configuration."""
        self.config = config
        self.browser_manager = BrowserManager()
        self.chrome_testing_manager = ChromeTestingManager(config)
        self.chrome_manager = ChromeManager(config.chrome)
        self.oauth_automator = OAuthAutomator(config.chrome.debug_port)
        self.executor = GeminiExecutor(config.gemini.executable)
        self.parser = ResponseParser()

    async def execute_with_auth(
        self, args: list[str], user_email: str | None = None
    ) -> str | None:
        """Execute Gemini CLI with automatic OAuth handling."""
        # Resolve user email
        resolved_email = UserResolver.resolve_user_email(
            user_email, self.chrome_testing_manager.get_stored_user
        )

        # Save original browser
        orig_browser = self.browser_manager.get_current_default()
        logger.debug(f"Original default browser: {orig_browser}")

        # Ensure Chrome for Testing is available
        chrome_testing_path = self.chrome_testing_manager.ensure_available()
        logger.debug(f"Chrome for Testing path: {chrome_testing_path}")

        chrome_proc = None
        try:
            # Set Chrome for Testing as default browser
            if orig_browser != BrowserID.TESTING:
                logger.debug(f"Setting '{BrowserID.TESTING}' as default browser")
                self.browser_manager.set_default(BrowserID.TESTING)

            # Launch Chrome if needed
            if self.chrome_manager.is_cdp_ready():
                logger.debug("Chrome CDP already listening — using existing browser.")
            else:
                logger.debug("Launching Chrome for Testing with remote debugging…")
                chrome_proc = self.chrome_manager.launch(chrome_testing_path)

            # Wait for Chrome CDP to be ready
            await self.chrome_manager.wait_for_cdp()

            # Try running gemini with original args
            response = await self._try_gemini_with_oauth(args, resolved_email)

            if response is None:
                # Check if we should retry with flash model
                if "-m" not in args and "--model" not in args:
                    logger.debug(
                        "Rate limit detected, retrying with gemini-2.5-flash model..."
                    )
                    flash_args = ["-m", "gemini-2.5-flash", *args]
                    response = await self._try_gemini_with_oauth(
                        flash_args, resolved_email
                    )
                else:
                    logger.debug(
                        "Rate limit detected but model already specified, not retrying"
                    )

            # Store successful user for future use
            if response and resolved_email:
                self.chrome_testing_manager.set_stored_user(resolved_email)

            return response

        finally:
            # Restore browser
            if orig_browser != BrowserID.TESTING:
                self.browser_manager.set_default(orig_browser)
                logger.debug(f"Restored default browser to {orig_browser}")

            # Optionally quit Chrome
            if chrome_proc and chrome_proc.poll() is None and self.config.chrome.quit_chrome:
                logger.debug("Quitting Chrome for Testing as requested.")
                chrome_proc.terminate()
                await asyncio.sleep(1)

    async def _try_gemini_with_oauth(
        self, args: list[str], user_email: str | None
    ) -> str | None:
        """Try running gemini with OAuth automation."""
        # Start Gemini CLI process
        proc, _, _ = await self.executor.execute(args, self.config.gemini.timeout)

        # Run OAuth automation
        logger.debug("Starting OAuth automation flow...")
        try:
            await self.oauth_automator.run_oauth_flow(user_email)
            logger.debug("Automation flow finished.")
        except Exception as e:
            logger.debug(f"OAuth automation failed: {e}")
            proc.terminate()
            return None

        # Monitor for rate limits
        logger.debug("Waiting for gemini process to complete...")
        rate_limit_detected, stderr_lines = await self.executor.monitor_process(proc)

        if rate_limit_detected:
            logger.debug("Terminating gemini process due to rate limit detection")
            proc.terminate()
            return None

        # Wait for completion
        try:
            stdout, stderr = await self.executor.wait_completion(
                proc, self.config.gemini.timeout
            )

            if stderr:
                stderr_lines.append(stderr)

            # Final check for rate limits
            all_stderr = "".join(stderr_lines)
            if self.executor.check_rate_limit(all_stderr):
                logger.debug("Rate limit detected in final output")
                return None

            if proc.returncode == 0:
                logger.debug("Gemini process completed successfully.")

                # Parse stdout to extract clean model response
                if stdout:
                    clean_response = self.parser.extract_clean_response(stdout)
                    if clean_response:
                        logger.debug(f"Clean model response: {clean_response}")
                        return clean_response
                    logger.debug("No clean model response found in output")
                    return None

            else:
                logger.debug(f"Gemini process failed with return code: {proc.returncode}")

            return None

        except subprocess.TimeoutExpired:
            logger.debug("Gemini process timed out")
            proc.terminate()
            return None
</file>

<file path="src/geminpy/gemini/executor.py">
# this_file: src/geminpy/gemini/executor.py
"""Manages Gemini CLI subprocess execution."""

import asyncio
import subprocess
from pathlib import Path

from loguru import logger

from geminpy.core.constants import RateLimitIndicators


class GeminiExecutor:
    """Manages Gemini CLI subprocess execution."""

    def __init__(self, executable: str | Path = "gemini"):
        """Initialize with Gemini executable path."""
        self.executable = str(executable)

    async def execute(
        self, args: list[str], timeout: int = 120
    ) -> tuple[int, str, str]:
        """Execute gemini CLI and return (returncode, stdout, stderr)."""
        # Ensure -y flag is present
        if "-y" not in args and "--yes" not in args:
            args = ["-y", *args]

        cmd = [self.executable, *args]
        logger.debug(f"Running gemini: {' '.join(cmd)}")

        # Create subprocess with real-time monitoring
        proc = subprocess.Popen(
            cmd,
            stderr=subprocess.PIPE,
            stdout=subprocess.PIPE,
            text=True,
            bufsize=1,
            universal_newlines=True,
        )

        # Give gemini a moment to open the URL
        await asyncio.sleep(2)

        return proc, None, None  # Return process for monitoring

    def check_rate_limit(self, text: str) -> bool:
        """Check if text contains rate limit indicators."""
        return any(pattern in text for pattern in RateLimitIndicators.PATTERNS)

    async def monitor_process(
        self, proc: subprocess.Popen, monitor_time: int = 15
    ) -> tuple[bool, list[str]]:
        """Monitor process for rate limits and collect stderr."""
        rate_limit_detected = False
        stderr_lines = []

        # Monitor process for up to monitor_time seconds
        start_time = asyncio.get_event_loop().time()
        while (
            proc.poll() is None
            and (asyncio.get_event_loop().time() - start_time) < monitor_time
        ):
            # Check if there's new stderr output
            if proc.stderr and proc.stderr.readable():
                try:
                    # Non-blocking read of available stderr data
                    import select

                    if select.select([proc.stderr], [], [], 0.1)[0]:
                        line = proc.stderr.readline()
                        if line:
                            stderr_lines.append(line)
                            logger.debug(f"Gemini stderr: {line.strip()}")

                            # Check for rate limit indicators
                            if self.check_rate_limit(line):
                                logger.debug("Rate limit detected in real-time output!")
                                rate_limit_detected = True
                                break
                except:
                    pass

            await asyncio.sleep(0.5)

        return rate_limit_detected, stderr_lines

    async def wait_completion(
        self, proc: subprocess.Popen, timeout: int = 90
    ) -> tuple[str, str]:
        """Wait for process completion and return stdout, stderr."""
        try:
            stdout, stderr = proc.communicate(timeout=timeout)
            logger.debug(f"Gemini process completed with return code: {proc.returncode}")
            return stdout or "", stderr or ""
        except subprocess.TimeoutExpired:
            logger.debug("Gemini process timed out - terminating...")
            proc.terminate()
            raise
</file>

<file path="src/geminpy/gemini/parser.py">
# this_file: src/geminpy/gemini/parser.py
"""Parses and cleans Gemini CLI output."""

from loguru import logger


class ResponseParser:
    """Parses and cleans Gemini CLI output."""

    AUTH_PATTERNS = [
        "Code Assist login required",
        "Attempting to open authentication page",
        "Otherwise navigate to:",
        "https://accounts.google.com/o/oauth2",
        "Waiting for authentication...",
        "Authentication successful",
        "[dotenv@",
    ]

    def extract_clean_response(self, stdout: str) -> str | None:
        """Extract clean model response from mixed output."""
        lines = stdout.strip().split("\n")

        # Skip authentication-related lines and find the actual response
        response_lines = []
        found_auth_complete = False

        for line in lines:
            line = line.strip()

            # Skip dotenv messages
            if line.startswith("[dotenv@"):
                continue

            # Skip authentication messages
            if any(auth_phrase in line for auth_phrase in self.AUTH_PATTERNS):
                continue

            # Skip empty lines at the start
            if not line and not response_lines:
                continue

            # If we find "Waiting for authentication...", the next non-empty line is likely the response
            if "Waiting for authentication..." in stdout:
                found_auth_complete = True

            # Collect non-authentication content
            if line:
                response_lines.append(line)

        # Return the cleaned response
        if response_lines:
            # If there's authentication flow, the response is typically the last meaningful content
            if found_auth_complete and response_lines:
                # Find the first line after authentication that looks like a response
                for i, line in enumerate(response_lines):
                    if not any(
                        skip_phrase in line
                        for skip_phrase in [
                            "dotenv",
                            "Code Assist",
                            "Attempting",
                            "navigate",
                            "oauth2",
                            "Waiting",
                        ]
                    ):
                        # Return from this line to the end
                        return "\n".join(response_lines[i:])

            # Fallback: return all non-auth lines
            return "\n".join(response_lines)

        return None
</file>

<file path="src/geminpy/utils/__init__.py">
# this_file: src/geminpy/utils/__init__.py
"""Utility components for Geminpy."""

from geminpy.utils.logging import setup_logging
from geminpy.utils.platform import check_dependencies, require_command, require_macos
from geminpy.utils.storage import SettingsManager

__all__ = [
    "SettingsManager",
    "check_dependencies",
    "require_command",
    "require_macos",
    "setup_logging",
]
</file>

<file path="src/geminpy/utils/logging.py">
# this_file: src/geminpy/utils/logging.py
"""Centralized logging configuration using Loguru."""

import sys

from loguru import logger


def setup_logging(verbose: bool = False) -> None:
    """Configure loguru logging based on verbose flag."""
    logger.remove()  # Remove default handler
    if verbose:
        logger.add(
            sys.stderr,
            level="DEBUG",
            format="<level>{message}</level>",
            colorize=True,
        )
</file>

<file path="src/geminpy/utils/platform.py">
# this_file: src/geminpy/utils/platform.py
"""Platform utilities and dependency checks."""

import platform
import subprocess

from geminpy.core.exceptions import PlatformError


def require_macos() -> None:
    """Ensure running on macOS."""
    if platform.system() != "Darwin":
        msg = "This package currently only supports macOS"
        raise PlatformError(msg)


def require_command(command: str, install_hint: str) -> None:
    """Check if command exists, raise with install hint if not."""
    try:
        subprocess.run([command, "--version"], capture_output=True, check=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        msg = f"Required command '{command}' not found. {install_hint}"
        raise PlatformError(msg)


def check_dependencies() -> None:
    """Verify all required dependencies are available."""
    require_macos()
    require_command("macdefaultbrowsy", "Install with: brew install macdefaultbrowsy")
    require_command("npx", "Install Node.js from https://nodejs.org")
</file>

<file path="src/geminpy/utils/storage.py">
# this_file: src/geminpy/utils/storage.py
"""Settings storage management using platformdirs."""

import json
from pathlib import Path

from loguru import logger


class SettingsManager:
    """Manages persistent settings storage."""

    def __init__(self, settings_dir: Path):
        """Initialize settings manager with directory path."""
        self.settings_dir = settings_dir
        self.settings_file = settings_dir / "settings.json"

    def _load_settings(self) -> dict:
        """Load settings from disk."""
        if not self.settings_file.exists():
            return {}
        try:
            with open(self.settings_file) as f:
                return json.load(f)
        except (json.JSONDecodeError, OSError) as e:
            logger.warning(f"Failed to load settings: {e}")
            return {}

    def _save_settings(self, settings: dict) -> None:
        """Save settings to disk."""
        self.settings_dir.mkdir(parents=True, exist_ok=True)
        with open(self.settings_file, "w") as f:
            json.dump(settings, f, indent=2)

    def get(self, key: str, default: str | None = None) -> str | None:
        """Get a setting value."""
        settings = self._load_settings()
        return settings.get(key, default)

    def set(self, key: str, value: str) -> None:
        """Set a setting value."""
        settings = self._load_settings()
        settings[key] = value
        self._save_settings(settings)

    def delete(self, key: str) -> None:
        """Delete a setting."""
        settings = self._load_settings()
        if key in settings:
            del settings[key]
            self._save_settings(settings)
</file>

<file path="src/geminpy/__init__.py">
# this_file: src/geminpy/__init__.py
"""Geminpy - Automated OAuth wrapper for Google's Gemini CLI."""

try:
    from geminpy.__version__ import __version__
except ImportError:
    __version__ = "0.0.0"  # Default version when not installed

from geminpy.api import ask, call_gemini_cli

__all__ = ["__version__", "ask", "call_gemini_cli"]
</file>

<file path="src/geminpy/__main__.py">
# this_file: src/geminpy/__main__.py
"""Entry point for python -m geminpy."""

import sys

from geminpy.cli import main

if __name__ == "__main__":
    sys.exit(main())
</file>

<file path="src/geminpy/api.py">
# this_file: src/geminpy/api.py
"""High-level API for Geminpy."""

import asyncio
from pathlib import Path

from geminpy.core.config import AppConfig
from geminpy.core.exceptions import GeminiError
from geminpy.gemini.client import GeminiClient
from geminpy.utils.logging import setup_logging
from geminpy.utils.platform import check_dependencies


async def call_gemini_cli(
    gemini_args: list[str],
    quit_chrome: bool = False,
    user: str | None = None,
    gemini_executable: str | Path = "gemini",
    verbose: bool = False,
) -> str | None:
    """Core function to call gemini CLI with OAuth automation.

    Args:
        gemini_args: Arguments to pass to the gemini CLI
        quit_chrome: Whether to quit Chrome after execution
        user: Optional specific user email to use for authentication
        gemini_executable: Path to the gemini executable
        verbose: Enable debug logging

    Returns:
        Clean response text from Gemini or None if failed

    Raises:
        GeminiError: If authentication or API call fails
    """
    # Setup logging
    setup_logging(verbose)

    # Check dependencies
    check_dependencies()

    # Create configuration
    config = AppConfig(
        verbose=verbose,
        user_email=user,
    )
    config.gemini.executable = gemini_executable
    config.chrome.quit_chrome = quit_chrome

    # Create and run client
    client = GeminiClient(config)
    return await client.execute_with_auth(gemini_args, user)


async def ask_async(
    prompt: str,
    user: str | None = None,
    verbose: bool = False,
) -> str:
    """Async version of ask.

    Args:
        prompt: The question/prompt to ask
        user: Optional specific user email to use for authentication
        verbose: Enable debug logging

    Returns:
        Clean text response from Gemini

    Raises:
        GeminiError: If authentication or API call fails
    """
    gemini_args = ["-p", prompt]
    response = await call_gemini_cli(
        gemini_args=gemini_args, user=user, verbose=verbose
    )

    if response is None:
        msg = "Failed to get response from Gemini"
        raise GeminiError(msg)

    return response


def ask(
    prompt: str,
    user: str | None = None,
    verbose: bool = False,
) -> str:
    """Ask Gemini a question and get a clean response.

    Args:
        prompt: The question/prompt to ask
        user: Optional specific user email to use for authentication
        verbose: Enable debug logging

    Returns:
        Clean text response from Gemini

    Raises:
        GeminiError: If authentication or API call fails
    """
    return asyncio.run(ask_async(prompt, user, verbose))
</file>

<file path="tests/test_browser/test_automation.py">
# this_file: tests/test_browser/test_automation.py
"""Tests for the OAuthAutomator."""

import os
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from geminpy.browser.automation import OAuthAutomator, UserResolver
from geminpy.core.exceptions import AuthenticationError


class TestUserResolver:
    """Tests for the UserResolver class."""

    def test_resolve_user_email_cli_priority(self):
        """Verify CLI argument has highest priority."""
        result = UserResolver.resolve_user_email(cli_user="cli@example.com")
        assert result == "cli@example.com"

    @patch.dict(os.environ, {"GEMINI_CLI_USER": "env@example.com"})
    def test_resolve_user_email_env_priority(self):
        """Verify environment variable has second priority."""
        result = UserResolver.resolve_user_email()
        assert result == "env@example.com"

    def test_resolve_user_email_settings_priority(self):
        """Verify stored settings have third priority."""
        def mock_getter():
            return "stored@example.com"

        result = UserResolver.resolve_user_email(settings_getter=mock_getter)
        assert result == "stored@example.com"

    def test_resolve_user_email_none_fallback(self):
        """Verify fallback to None when no user configured."""
        result = UserResolver.resolve_user_email()
        assert result is None


class TestOAuthAutomator:
    """Tests for the OAuthAutomator class."""

    def test_oauth_automator_init(self):
        """Verify OAuthAutomator initializes with correct debug port."""
        automator = OAuthAutomator(debug_port=9999)
        assert automator.debug_port == 9999

    def test_oauth_automator_default_port(self):
        """Verify OAuthAutomator uses default port 9222."""
        automator = OAuthAutomator()
        assert automator.debug_port == 9222

    @patch("geminpy.browser.automation.requests.get")
    @patch("geminpy.browser.automation.async_playwright")
    @pytest.mark.asyncio
    async def test_connect_playwright_success(self, mock_playwright, mock_get):
        """Test successful Playwright connection to Chrome."""
        # Mock the CDP version endpoint
        mock_get.return_value.json.return_value = {
            "webSocketDebuggerUrl": "ws://localhost:9222/devtools/browser"
        }

        # Mock Playwright components
        mock_pw = AsyncMock()
        mock_playwright.return_value.start = AsyncMock(return_value=mock_pw)
        mock_browser = AsyncMock()
        mock_pw.chromium.connect_over_cdp = AsyncMock(return_value=mock_browser)

        # Mock browser context and page
        mock_context = AsyncMock()
        mock_page = AsyncMock()
        mock_page.url = "https://accounts.google.com/signin/oauth"
        mock_context.pages = [mock_page]
        mock_browser.contexts = [mock_context]

        automator = OAuthAutomator()
        pw, page = await automator._connect_playwright()

        assert pw == mock_pw
        assert page == mock_page
        mock_page.bring_to_front.assert_called_once()

    @patch("geminpy.browser.automation.asyncio.sleep", new_callable=AsyncMock)
    @patch("geminpy.browser.automation.requests.get")
    @patch("geminpy.browser.automation.async_playwright")
    @pytest.mark.asyncio
    async def test_connect_playwright_no_oauth_page(
        self, mock_playwright, mock_get, mock_sleep
    ):
        """Test failure when no OAuth page is found."""
        # Mock the CDP version endpoint
        mock_get.return_value.json.return_value = {
            "webSocketDebuggerUrl": "ws://localhost:9222/devtools/browser"
        }

        # Mock Playwright components
        mock_pw = AsyncMock()
        mock_playwright.return_value.start = AsyncMock(return_value=mock_pw)
        mock_browser = AsyncMock()
        mock_pw.chromium.connect_over_cdp = AsyncMock(return_value=mock_browser)

        # Mock browser context with no OAuth pages
        mock_context = AsyncMock()
        mock_page = AsyncMock()
        mock_page.url = "https://example.com"  # Not an OAuth page
        mock_context.pages = [mock_page]
        mock_browser.contexts = [mock_context]

        automator = OAuthAutomator()

        with pytest.raises(AuthenticationError, match="Could not find a Google Accounts page"):
            await automator._connect_playwright()

        # Verify sleep was called (indicating the retry loop ran)
        assert mock_sleep.call_count == 8  # Should retry 8 times
</file>

<file path="tests/test_browser/test_chrome.py">
# this_file: tests/test_browser/test_chrome.py
"""Tests for the ChromeManager and ChromeTestingManager."""

from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest
import requests

from geminpy.browser.chrome import ChromeManager, ChromeTestingManager
from geminpy.core.config import AppConfig, ChromeConfig


@pytest.fixture
def app_config(tmp_path):
    """Pytest fixture for a mock AppConfig."""
    with patch("geminpy.core.config.user_data_dir", return_value=str(tmp_path)):
        yield AppConfig()


@pytest.fixture
def chrome_testing_manager(app_config):
    """Pytest fixture for a ChromeTestingManager instance."""
    return ChromeTestingManager(app_config)


@pytest.fixture
def chrome_manager():
    """Pytest fixture for a ChromeManager instance."""
    return ChromeManager(ChromeConfig())


def test_chrome_testing_manager_get_stored_path(chrome_testing_manager):
    """Verify that the manager can retrieve a stored path."""
    test_path = "/fake/chrome/path"
    chrome_testing_manager.settings.set("chrome_testing_path", test_path)
    assert chrome_testing_manager.get_stored_path() == Path(test_path)


@patch("pathlib.Path.exists", return_value=True)
def test_ensure_available_with_stored_path(mock_exists, chrome_testing_manager):
    """Verify that ensure_available returns a stored path if it exists."""
    test_path = "/fake/chrome/path"
    chrome_testing_manager.settings.set("chrome_testing_path", str(test_path))
    assert chrome_testing_manager.ensure_available() == Path(test_path)
    mock_exists.assert_called()


@patch("geminpy.browser.chrome.subprocess.run")
@patch("geminpy.browser.manager.BrowserManager.get_available_browsers", return_value=[])
def test_ensure_available_installs_if_needed(
    mock_browsers, mock_run, chrome_testing_manager, tmp_path
):
    """Verify that ensure_available installs Chrome if it's not found."""
    install_path = tmp_path / "chrome"
    mock_run.return_value.stdout = f"chrome@stable {install_path}"

    # Mock the path's existence to avoid a FileNotFoundError in the test
    with patch.object(Path, "exists", return_value=True):
        result_path = chrome_testing_manager.install()

    assert result_path == install_path
    assert chrome_testing_manager.get_stored_path() == install_path


@patch("subprocess.Popen")
def test_chrome_manager_launch(mock_popen, chrome_manager, tmp_path):
    """Verify that ChromeManager launches Chrome with the correct arguments."""
    executable_path = tmp_path / "chrome"
    chrome_manager.launch(executable_path)
    mock_popen.assert_called_once()
    args, _ = mock_popen.call_args
    assert str(executable_path) in args[0]
    assert (
        f"--remote-debugging-port={chrome_manager.config.debug_port}" in args[0]
    )


@patch("requests.get")
def test_chrome_manager_is_cdp_ready(mock_get, chrome_manager):
    """Verify that is_cdp_ready correctly checks the CDP endpoint."""
    mock_get.return_value.status_code = 200
    assert chrome_manager.is_cdp_ready() is True

    mock_get.side_effect = requests.RequestException
    assert chrome_manager.is_cdp_ready() is False


@patch("requests.get")
@patch("asyncio.sleep", new_callable=MagicMock)
@pytest.mark.asyncio
async def test_chrome_manager_wait_for_cdp(
    mock_sleep, mock_get, chrome_manager
):
    """Verify that wait_for_cdp waits for a successful connection."""
    mock_get.return_value.status_code = 200
    await chrome_manager.wait_for_cdp()
    mock_get.assert_called_once()
    mock_sleep.assert_not_called()
</file>

<file path="tests/test_browser/test_manager.py">
# this_file: tests/test_browser/test_manager.py
"""Tests for the BrowserManager."""

from unittest.mock import MagicMock, patch

from geminpy.browser.manager import BrowserManager


@patch("geminpy.browser.manager.require_command")
@patch("subprocess.run")
def test_get_current_default(mock_run, mock_require):
    """Verify that get_current_default correctly parses macdefaultbrowsy output."""
    mock_process = MagicMock()
    mock_process.stdout = "safari\n* chrome\nfirefox\n"
    mock_run.return_value = mock_process

    default_browser = BrowserManager.get_current_default()
    assert default_browser == "chrome"
    mock_require.assert_called_once()


@patch("geminpy.browser.manager.require_command")
@patch("subprocess.run")
def test_get_current_default_none(mock_run, mock_require):
    """Verify that get_current_default handles empty output."""
    mock_process = MagicMock()
    mock_process.stdout = ""
    mock_run.return_value = mock_process

    default_browser = BrowserManager.get_current_default()
    assert default_browser is None
    mock_require.assert_called_once()


@patch("geminpy.browser.manager.require_command")
@patch("subprocess.run")
def test_get_available_browsers(mock_run, mock_require):
    """Verify that get_available_browsers correctly parses macdefaultbrowsy output."""
    mock_process = MagicMock()
    mock_process.stdout = "safari\n* chrome\nfirefox\n"
    mock_run.return_value = mock_process

    browsers = BrowserManager.get_available_browsers()
    assert browsers == ["safari", "chrome", "firefox"]
    mock_require.assert_called_once()


@patch("geminpy.browser.manager.require_command")
@patch("subprocess.run")
def test_set_default_success(mock_run, mock_require):
    """Verify that set_default calls macdefaultbrowsy with the correct arguments."""
    # Mock get_current_default to return different browser
    mock_process = MagicMock()
    mock_process.stdout = "safari\n* chrome\nfirefox\n"
    mock_run.return_value = mock_process

    result = BrowserManager.set_default("firefox")
    assert result is True
    assert mock_run.call_count == 2  # One for get_current_default, one for set
    mock_require.assert_called()


@patch("geminpy.browser.manager.require_command")
@patch("subprocess.run")
def test_set_default_already_default(mock_run, mock_require):
    """Verify that set_default returns True without calling CLI if browser is already default."""
    # Mock get_current_default to return the same browser
    mock_process = MagicMock()
    mock_process.stdout = "safari\n* firefox\nchrome\n"
    mock_run.return_value = mock_process

    result = BrowserManager.set_default("firefox")
    assert result is True
    assert mock_run.call_count == 1  # Only one call for get_current_default
    assert mock_require.call_count == 2  # Called in both methods


@patch("geminpy.browser.manager.require_command")
@patch("subprocess.run")
def test_list_browsers(mock_run, mock_require):
    """Verify that list_browsers calls macdefaultbrowsy and logs output."""
    mock_process = MagicMock()
    mock_process.stdout = "safari\n* chrome\nfirefox\n"
    mock_run.return_value = mock_process

    BrowserManager.list_browsers()
    mock_require.assert_called_once()
    mock_run.assert_called_once()
</file>

<file path="tests/test_gemini/test_client.py">
# this_file: tests/test_gemini/test_client.py
"""Tests for the GeminiClient."""
</file>

<file path="tests/test_utils/test_platform.py">
# this_file: tests/test_utils/test_platform.py
"""Tests for the platform utilities."""

import subprocess
from unittest.mock import patch

import pytest

from geminpy.core.exceptions import PlatformError
from geminpy.utils.platform import (
    check_dependencies,
    require_command,
    require_macos,
)


def test_require_macos_on_mac():
    """Verify that require_macos does not raise on macOS."""
    with patch("platform.system", return_value="Darwin"):
        require_macos()  # Should not raise


def test_require_macos_on_other_os():
    """Verify that require_macos raises PlatformError on other OS."""
    with patch("platform.system", return_value="Linux"):
        with pytest.raises(PlatformError, match="currently only supports macOS"):
            require_macos()


def test_require_command_exists():
    """Verify that require_command does not raise if command exists."""
    with patch("subprocess.run") as mock_run:
        mock_run.return_value = subprocess.CompletedProcess(args=[], returncode=0)
        require_command("any_command", "install hint")  # Should not raise


def test_require_command_does_not_exist():
    """Verify that require_command raises PlatformError if command is missing."""
    with (
        patch("subprocess.run", side_effect=FileNotFoundError),
        pytest.raises(PlatformError, match="Required command 'any_command' not found"),
    ):
        require_command("any_command", "install hint")


def test_check_dependencies_success():
    """Verify check_dependencies runs without error when all dependencies are met."""
    with patch("geminpy.utils.platform.require_macos") as mock_require_macos:
        with patch("geminpy.utils.platform.require_command") as mock_require_command:
            check_dependencies()
            assert mock_require_macos.called
            assert mock_require_command.call_count == 2  # macdefaultbrowsy and npx


def test_check_dependencies_missing_command():
    """Verify check_dependencies raises PlatformError if a command is missing."""
    with patch("geminpy.utils.platform.require_macos"):
        with patch("geminpy.utils.platform.require_command", side_effect=PlatformError):
            with pytest.raises(PlatformError):
                check_dependencies()
</file>

<file path="tests/test_utils/test_storage.py">
# this_file: tests/test_utils/test_storage.py
"""Tests for the SettingsManager."""

from geminpy.utils.storage import SettingsManager


def test_settings_manager_set_get(tmp_path):
    """Verify that SettingsManager can set and get a setting."""
    settings_dir = tmp_path / "settings"
    manager = SettingsManager(settings_dir)

    # Test setting and getting a value
    manager.set("test_key", "test_value")
    assert manager.get("test_key") == "test_value"

    # Test that a non-existent key returns the default
    assert manager.get("non_existent_key") is None
    assert manager.get("non_existent_key", "default") == "default"

    # Test that the settings file was created
    settings_file = settings_dir / "settings.json"
    assert settings_file.exists()
    with open(settings_file) as f:
        content = f.read()
        assert '"test_key": "test_value"' in content
</file>

<file path="tests/conftest.py">
# this_file: tests/conftest.py
"""Pytest fixtures for the test suite."""
</file>

<file path="tests/test_api.py">
# this_file: tests/test_api.py
"""Tests for the high-level API."""

from geminpy.api import ask


def test_ask_importable():
    """Verify that the ask function can be imported."""
    assert callable(ask)
</file>

<file path="tests/test_cli.py">
# this_file: tests/test_cli.py
"""Tests for the CLI."""
</file>

<file path="tests/test_package.py">
"""Test suite for geminpy."""

def test_version():
    """Verify package exposes version."""
    import geminpy
    assert geminpy.__version__
</file>

<file path=".cursorindexingignore">
# Don't index SpecStory auto-save files, but allow explicit context inclusion via @ references
.specstory/**
</file>

<file path=".pre-commit-config.yaml">
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- **Multi-language OAuth Support**: Enhanced OAuth button detection to support 9+ languages
  - Added support for Polish, French, German, Spanish, Italian, Russian, Japanese, and Chinese
  - Implemented multiple fallback strategies for button detection (by text, attributes, and styling)
  - Addresses issue #101 where authentication failed on non-English Google OAuth pages
- **CLI Model Shortcuts**: Added convenient shortcuts for common Gemini models
  - `-P` / `--Pro` as shortcut for `-m 'gemini-2.5-pro'`
  - `-F` / `--Flash` as shortcut for `-m 'gemini-2.5-flash'`
  - Includes warnings when shortcuts override existing model arguments
- **Enhanced Browser Management**: Improved `BrowserManager` with hanging prevention
  - Added check to prevent hanging when setting browser that's already default
  - Enhanced error handling and logging throughout browser management
  - Maintains compatibility with `macdefaultbrowsy` CLI tool
- **Comprehensive Test Suite**: 45 tests with 72% overall coverage
  - Browser module tests: OAuth automation, Chrome management, browser switching
  - Gemini module tests: CLI execution, response parsing, rate limit detection
  - Core utilities tests: Platform checks, settings management, error handling
  - All tests use proper mocking and async/await patterns

### Changed
- Improved OAuth automation robustness with multi-strategy button detection
- Enhanced CLI argument handling with Fire framework
- Improved code quality with automatic linting and formatting fixes
- Enhanced error handling and type safety throughout the codebase
- **Browser Management**: Investigated using `macdefaultbrowsy` Python package but reverted to CLI approach due to incomplete package

### Technical Notes
- Attempted integration with `macdefaultbrowsy` Python package for more reliable browser management
- Package was found to be incomplete (missing core modules) so reverted to `macdefaultbrowsy` CLI
- Added hanging prevention logic directly in `BrowserManager.set_default()` method
- All tests updated and passing with the CLI-based approach

## [0.1.0] - 2024-07-26

### Added
- Initial release of `geminpy`.
- Ported all functionality from the original `work/gemini_wrapper.py` script.
- Created a structured Python package with a modular architecture.
- **Core**: Configuration, custom exceptions, and constants.
- **Browser Management**:
    - `BrowserManager` for macOS default browser control.
    - `ChromeTestingManager` for automatic installation and management of Chrome for Testing.
    - `ChromeManager` for launching Chrome with remote debugging enabled.
- **OAuth Automation**:
    - `OAuthAutomator` using Playwright for automated Google account selection and sign-in.
    - `UserResolver` for intelligent user account resolution from multiple sources.
- **Gemini Integration**:
    - `GeminiClient` as the main orchestrator combining all components.
    - `GeminiExecutor` for subprocess management with real-time monitoring.
    - `ResponseParser` for extracting clean responses from CLI output.
- **Utilities**:
    - Platform validation ensuring macOS compatibility.
    - Settings management using platformdirs for cross-platform storage.
    - Centralized logging with Loguru.
- **High-Level API**:
    - Simple `ask()` function for direct usage.
    - Async `call_gemini_cli()` for advanced scenarios.
- **CLI Interface**:
    - Fire-based command-line interface with Rich formatting.
    - Full backward compatibility with original script arguments.
- **Error Handling**:
    - Automatic rate limit detection and retry with fallback model.
    - Comprehensive error types for different failure scenarios.
    - Graceful degradation and informative error messages.
- **Modern Python Features**:
    - Full type hints with union syntax (str | None).
    - Async/await throughout for non-blocking operations.
    - Dataclasses for configuration management.
    - Context managers for resource cleanup.

### Technical Details
- **Dependencies**: Fire, Playwright, Requests, Platformdirs, Loguru, Rich
- **Python Support**: 3.10, 3.11, 3.12
- **Build System**: Hatchling with VCS versioning
- **Code Quality**: Ruff linting, MyPy type checking, comprehensive test suite
- **Platform**: macOS only (due to browser management requirements)

### Migration Notes
- All original `gemini_wrapper.py` functionality is preserved
- Settings are automatically migrated to new location
- CLI arguments remain identical for seamless transition
- New programmatic API available for integration use cases
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package.toml">
# Package configuration
[package]
include_cli = true        # Include CLI boilerplate
include_logging = true    # Include logging setup
use_pydantic = true      # Use Pydantic for data validation
use_rich = true          # Use Rich for terminal output

[features]
mkdocs = false           # Enable MkDocs documentation
vcs = true              # Initialize Git repository
github_actions = true   # Add GitHub Actions workflows
</file>

<file path="TODO.md">
# TODO.md - Geminpy Porting & Refactoring Plan

## Overview

Port the monolithic `work/gemini_wrapper.py` script into a well-structured Python package `geminpy` with proper separation of concerns, comprehensive testing, and modern Python best practices.

## Phase 1: ✅ COMPLETED

- [x] Address `issues/101.txt` - Fixed OAuth button detection to handle multiple languages
- [x] In our CLI add `-P` / `--Pro` as a shortcut for `-m 'gemini-2.5-pro'` and `-F` / `--Flash` as a shortcut for `-m 'gemini-2.5-flash'` (that is, our CLI takes these args and puts the -m nnnn into the gemini args)

## Phase 8: Documentation

### [ ] 8.1 Update Package Documentation

- Comprehensive docstrings for all modules
- Type hints for all functions
- Examples in docstrings

### [ ] 8.2 Create User Documentation

- Update README.md with new usage
- API reference with examples
- Troubleshooting guide

## Phase 9: Quality Assurance

### [ ] 9.1 Code Quality

- Run mypy with strict mode
- Achieve 100% type coverage
- Run ruff with all rules
- Format with comprehensive toolchain

### [ ] 9.2 Test Coverage

- Achieve >90% test coverage
- Cover all error paths
- Test async code thoroughly
- Benchmark performance

### [ ] 9.3 Security Review

- No credential storage
- Secure subprocess execution
- Validate all inputs
- Review OAuth flow security


### [ ] 10.3 Package Release

- Set up GitHub Actions CI/CD
- Configure automatic versioning
- Create release workflow
- Publish to PyPI
</file>

<file path="src/geminpy/browser/automation.py">
# this_file: src/geminpy/browser/automation.py
"""OAuth flow automation using Playwright."""

import asyncio
import os
import re

import requests
from loguru import logger
from playwright.async_api import Page, Playwright, async_playwright

from geminpy.core.constants import CDP_VERSION_URL, SUCCESS_PATTERN
from geminpy.core.exceptions import AuthenticationError


class OAuthAutomator:
    """Handles OAuth flow automation using Playwright."""

    def __init__(self, debug_port: int = 9222):
        """Initialize with Chrome debug port."""
        self.debug_port = debug_port

    async def _connect_playwright(self) -> tuple[Playwright, Page]:
        """Connect to Chrome via CDP and return playwright instance and OAuth page."""
        logger.debug("Connecting to Chrome over CDP...")
        info = requests.get(CDP_VERSION_URL.format(port=self.debug_port), timeout=10).json()
        ws_url = info["webSocketDebuggerUrl"]
        pw = await async_playwright().start()
        browser = await pw.chromium.connect_over_cdp(ws_url)

        if not browser.contexts:
            msg = "No browser contexts found. Is Chrome running correctly?"
            raise AuthenticationError(
                msg
            )
        context = browser.contexts[0]

        # Find the OAuth page
        logger.debug("Searching for Google OAuth page among open tabs...")
        for _ in range(8):  # Reduced from 15 to 8 seconds
            for page in context.pages:
                try:
                    url = page.url
                    if "accounts.google.com" in url:
                        logger.debug(f"Found potential OAuth page: {url}")
                        await page.bring_to_front()
                        return pw, page
                except Exception as e:
                    logger.debug(f"Could not check a page, it might be closed: {e}")
            logger.debug("OAuth page not found yet, retrying...")
            await asyncio.sleep(1)

        msg = "Could not find a Google Accounts page to automate."
        raise AuthenticationError(msg)

    async def _wait_for_url(
        self, page: Page, pattern: re.Pattern, timeout: int = 120
    ) -> None:
        """Wait for page URL to match pattern."""
        await page.wait_for_url(pattern, wait_until="load", timeout=timeout * 1000)

    async def run_oauth_flow(self, user_email: str | None) -> None:
        """Execute the complete OAuth flow."""
        pw, page = await self._connect_playwright()
        try:
            logger.debug(f"Automating page: {page.url}")

            # Wait for page to be ready
            await page.wait_for_load_state(
                "domcontentloaded", timeout=15000
            )  # Reduced from 20s
            await asyncio.sleep(1)  # Reduced from 2 seconds

            # Step 1: Click the account
            if user_email:
                logger.debug(f"Looking for specific account: {user_email}")
                # Try direct data-identifier selection first
                account_locator = page.locator(f'[data-identifier="{user_email}"]')

                if await account_locator.count() == 0:
                    logger.debug(
                        f"Specific account '{user_email}' not found by data-identifier, trying by text content"
                    )
                    # Fallback to searching by text content in links
                    account_locator = page.get_by_role(
                        "link", name=re.compile(user_email, re.IGNORECASE)
                    )

                    if await account_locator.count() == 0:
                        logger.debug(
                            f"Specific account '{user_email}' not found, using first available account"
                        )
                        # Use first element with data-identifier
                        account_locator = page.locator("[data-identifier]").first
            else:
                logger.debug("Looking for first available account")
                # Use first element with data-identifier
                account_locator = page.locator("[data-identifier]").first

            account_count = await account_locator.count()
            if account_count == 0:
                await page.screenshot(path="oauth_error_no_account.png")
                target_desc = f"'{user_email}'" if user_email else "any account"
                msg = f"Could not find {target_desc} using direct selection."
                raise AuthenticationError(
                    msg
                )

            logger.debug(f"Account found ({account_count} matches), clicking it...")
            await account_locator.click()

            # Step 2: Click the sign-in button
            logger.debug("Waiting for the approval page to load...")
            await page.wait_for_load_state(
                "domcontentloaded", timeout=10000
            )  # Reduced from 15s
            await asyncio.sleep(1)  # Reduced from 2 seconds

            logger.debug("Looking for sign-in button...")

            # Try multiple strategies to find the sign-in button
            sign_in_button = None

            # Strategy 1: Look for button by text in multiple languages
            button_texts = [
                "Sign in", "Continue",  # English
                "Zaloguj się", "Dalej", "Kontynuuj",  # Polish
                "Se connecter", "Continuer",  # French
                "Anmelden", "Weiter",  # German
                "Acceder", "Continuar",  # Spanish
                "Accedi", "Continua",  # Italian
                "Войти", "Продолжить",  # Russian
                "ログイン", "続行",  # Japanese
                "登录", "继续",  # Chinese
            ]

            for text in button_texts:
                locator = page.get_by_role("button", name=re.compile(re.escape(text), re.IGNORECASE))
                if await locator.count() > 0:
                    sign_in_button = locator.first
                    logger.debug(f"Found sign-in button with text: {text}")
                    break

            # Strategy 2: If not found by text, look for buttons with specific attributes
            if not sign_in_button:
                # Look for buttons with common sign-in related attributes
                selectors = [
                    'button[type="submit"]',
                    'button[data-action="sign-in"]',
                    'button[jsname]',  # Google often uses jsname attributes
                    'div[role="button"][tabindex="0"]',  # Sometimes buttons are divs
                ]

                for selector in selectors:
                    elements = await page.query_selector_all(selector)
                    # Filter to visible elements that look like primary buttons
                    for element in elements:
                        if await element.is_visible():
                            # Check if it's likely a primary button (often blue/colored)
                            box = await element.bounding_box()
                            if box and box.get('width', 0) > 50:  # Reasonable button width
                                sign_in_button = element
                                logger.debug(f"Found sign-in button using selector: {selector}")
                                break
                    if sign_in_button:
                        break

            # Strategy 3: As last resort, look for the most prominent button
            if not sign_in_button:
                all_buttons = await page.query_selector_all('button, div[role="button"]')
                for button in all_buttons:
                    if await button.is_visible():
                        # Check for primary button styling (often has background color)
                        bg_color = await button.evaluate('(el) => window.getComputedStyle(el).backgroundColor')
                        if bg_color and bg_color != 'rgba(0, 0, 0, 0)' and 'rgb' in bg_color:
                            sign_in_button = button
                            logger.debug("Found sign-in button by styling")
                            break

            if not sign_in_button:
                await page.screenshot(path="oauth_error_no_signin.png")
                msg = "Could not find sign-in button using any strategy"
                raise AuthenticationError(msg)

            logger.debug("Sign-in button found, clicking it...")
            await sign_in_button.click()

            # Step 3: Wait for success and close tab
            logger.debug("Waiting for success redirect...")
            await self._wait_for_url(page, re.compile(SUCCESS_PATTERN), timeout=60)
            logger.debug("OAuth flow completed successfully ✔")
            logger.debug(f"Success page reached: {page.url}")

            logger.debug("Closing success tab...")
            await page.close()
            logger.debug("Success tab closed successfully")

        except Exception as e:
            logger.error(f"An error occurred during OAuth automation: {e}")
            await page.screenshot(path="oauth_error.png")
            logger.debug("Saved a screenshot to oauth_error.png for debugging.")
            raise
        finally:
            logger.debug("Stopping Playwright.")
            await pw.stop()


class UserResolver:
    """Resolves the target user email from multiple sources."""

    @staticmethod
    def resolve_user_email(
        cli_user: str | None = None, settings_getter=None
    ) -> str | None:
        """Resolve user email from multiple sources in priority order."""
        # 1. --user command line argument
        if cli_user:
            logger.debug(f"Using user from CLI argument: {cli_user}")
            return cli_user

        # 2. GEMINI_CLI_USER environment variable
        env_user = os.environ.get("GEMINI_CLI_USER")
        if env_user:
            logger.debug(f"Using user from GEMINI_CLI_USER env var: {env_user}")
            return env_user

        # 3. gemini_cli_user in settings.json
        if settings_getter:
            stored_user = settings_getter()
            if stored_user:
                logger.debug(f"Using user from settings.json: {stored_user}")
                return stored_user

        # 4. No specific user - will use first available account
        logger.debug("No specific user configured - will use first available account")
        return None
</file>

<file path="src/geminpy/browser/manager.py">
# this_file: src/geminpy/browser/manager.py
"""Manages default browser settings on macOS."""

import subprocess

from loguru import logger

from geminpy.utils.platform import require_command


class BrowserManager:
    """Manages default browser settings on macOS."""

    @staticmethod
    def _require_defaultbrowser() -> None:
        """Ensure macdefaultbrowsy utility is available."""
        require_command(
            "macdefaultbrowsy",
            "Install with: brew install macdefaultbrowsy"
        )

    @classmethod
    def get_current_default(cls) -> str | None:
        """Get current default browser identifier."""
        try:
            cls._require_defaultbrowser()
            result = subprocess.run(
                ["macdefaultbrowsy"],
                capture_output=True,
                text=True,
                check=True
            )
            for line in result.stdout.splitlines():
                line = line.strip()
                if line and line.startswith("* "):
                    return line[2:]
            return (
                result.stdout.splitlines()[0].strip()
                if result.stdout.splitlines() else None
            )
        except Exception as e:
            logger.error(f"Failed to get current default browser: {e}")
            return None

    @classmethod
    def get_available_browsers(cls) -> list[str]:
        """List all available browser identifiers."""
        try:
            cls._require_defaultbrowser()
            result = subprocess.run(
                ["macdefaultbrowsy"],
                capture_output=True,
                text=True,
                check=True
            )
            browsers = []
            for line in result.stdout.splitlines():
                line = line.strip()
                if line:
                    browsers.append(
                        line[2:] if line.startswith("* ") else line
                    )
            return browsers
        except Exception as e:
            logger.error(f"Failed to get available browsers: {e}")
            return []

    @classmethod
    def set_default(cls, browser_id: str) -> bool:
        """Set the default browser with hanging prevention.

        Returns:
            bool: True if successful, False otherwise.
        """
        try:
            cls._require_defaultbrowser()

            # Check if browser is already default to prevent hanging
            current_default = cls.get_current_default()
            if current_default == browser_id:
                logger.info(f"{browser_id} is already the default browser.")
                return True

            logger.debug(f"Setting default browser to: {browser_id}")
            subprocess.run(["macdefaultbrowsy", browser_id], check=True)
            return True
        except Exception as e:
            logger.error(f"Failed to set default browser to {browser_id}: {e}")
            return False

    @classmethod
    def list_browsers(cls) -> None:
        """List all available browsers, marking the default with a *."""
        try:
            cls._require_defaultbrowser()
            result = subprocess.run(
                ["macdefaultbrowsy"],
                capture_output=True,
                text=True,
                check=True
            )
            for line in result.stdout.splitlines():
                logger.info(line.strip())
        except Exception as e:
            logger.error(f"Failed to list browsers: {e}")
</file>

<file path="src/geminpy/cli.py">
# this_file: src/geminpy/cli.py
"""CLI interface for Geminpy using Fire and Rich."""

import asyncio
from pathlib import Path

import fire
from rich.console import Console

from geminpy.api import call_gemini_cli

console = Console()


def cli(
    quit_chrome: bool = False,
    verbose: bool = False,
    user: str | None = None,
    gemini_executable: str | Path = "gemini",
    P: bool = False,
    Pro: bool = False,
    F: bool = False,
    Flash: bool = False,
    **gemini_args,
) -> None:
    """CLI interface for gemini with automated OAuth via Playwright.

    Args:
        quit_chrome: Quit Chrome after execution
        verbose: Enable verbose debug logging
        user: Specific user email to use for authentication
        gemini_executable: Path to the gemini executable
        P, Pro: Shortcut for -m 'gemini-2.5-pro'
        F, Flash: Shortcut for -m 'gemini-2.5-flash'
        **gemini_args: Arguments to pass to the gemini CLI
    """
    # Handle model shortcuts
    if P or Pro:
        if 'm' in gemini_args or 'model' in gemini_args:
            console.print("[yellow]Warning: -P/--Pro overrides any existing -m/--model argument[/yellow]")
        gemini_args['m'] = 'gemini-2.5-pro'
    elif F or Flash:
        if 'm' in gemini_args or 'model' in gemini_args:
            console.print("[yellow]Warning: -F/--Flash overrides any existing -m/--model argument[/yellow]")
        gemini_args['m'] = 'gemini-2.5-flash'

    # Convert gemini_args dict to CLI argument list
    cli_args = []
    for key, value in gemini_args.items():
        # Use single dash for single char, double dash for multi-char
        flag = f"-{key}" if len(key) == 1 else f"--{key}"
        cli_args.append(flag)

        # Only add value if it's not a boolean True (flags don't need values)
        if value is not True:
            if value is False:
                # Skip false flags entirely
                cli_args.pop()  # Remove the flag we just added
            else:
                cli_args.append(str(value))

    # Run the command
    response = asyncio.run(
        call_gemini_cli(
            gemini_args=cli_args,
            quit_chrome=quit_chrome,
            user=user,
            gemini_executable=gemini_executable,
            verbose=verbose,
        )
    )

    # Print response if we got one (for CLI usage)
    if response:
        console.print(response)
    else:
        console.print("[red]Failed to get response from Gemini[/red]")


def main():
    """Main entry point for the CLI."""
    fire.Fire(cli)


if __name__ == "__main__":
    main()
</file>

<file path="src/geminpy/geminpy.py">
#!/usr/bin/env python3
"""geminpy:

Created by Adam Twardoch
"""

import logging
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

__version__ = "0.1.0"

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


@dataclass
class Config:
    """Configuration settings for geminpy."""
    name: str
    value: str | int | float
    options: dict[str, Any] | None = None


def process_data(
    data: list[Any],
    config: Config | None = None,
    *,
    debug: bool = False
) -> dict[str, Any]:
    """Process the input data according to configuration.

    Args:
        data: Input data to process
        config: Optional configuration settings
        debug: Enable debug mode

    Returns:
        Processed data as a dictionary

    Raises:
        ValueError: If input data is invalid
    """
    if debug:
        logger.setLevel(logging.DEBUG)
        logger.debug("Debug mode enabled")

    if not data:
        msg = "Input data cannot be empty"
        raise ValueError(msg)

    # TODO: Implement data processing logic
    result: dict[str, Any] = {}
    return result


def main() -> None:
    """Main entry point for geminpy."""
    try:
        # Example usage
        config = Config(
            name="default",
            value="test",
            options={"key": "value"}
        )
        result = process_data([], config=config)
        logger.info("Processing completed: %s", result)

    except Exception as e:
        logger.error("An error occurred: %s", str(e))
        raise


if __name__ == "__main__":
    main()
</file>

<file path="tests/test_gemini/test_executor.py">
# this_file: tests/test_gemini/test_executor.py
"""Tests for the GeminiExecutor."""

import subprocess
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from geminpy.gemini.executor import GeminiExecutor


class TestGeminiExecutor:
    """Tests for the GeminiExecutor class."""

    def test_executor_init_default(self):
        """Verify executor initializes with default gemini executable."""
        executor = GeminiExecutor()
        assert executor.executable == "gemini"

    def test_executor_init_custom(self):
        """Verify executor initializes with custom executable."""
        executor = GeminiExecutor("/custom/path/to/gemini")
        assert executor.executable == "/custom/path/to/gemini"

    @patch("subprocess.Popen")
    @patch("asyncio.sleep", new_callable=AsyncMock)
    @pytest.mark.asyncio
    async def test_execute_basic(self, mock_sleep, mock_popen):
        """Test basic execute method returns process."""
        mock_proc = MagicMock()
        mock_popen.return_value = mock_proc

        executor = GeminiExecutor()
        proc, stdout, stderr = await executor.execute(["-p", "test prompt"])

        assert proc == mock_proc
        assert stdout is None
        assert stderr is None

        # Verify the command was constructed correctly
        expected_cmd = ["gemini", "-y", "-p", "test prompt"]
        mock_popen.assert_called_once()
        args, kwargs = mock_popen.call_args
        assert args[0] == expected_cmd

    @patch("subprocess.Popen")
    @patch("asyncio.sleep", new_callable=AsyncMock)
    @pytest.mark.asyncio
    async def test_execute_with_existing_yes_flag(self, mock_sleep, mock_popen):
        """Test that -y flag is not duplicated if already present."""
        mock_proc = MagicMock()
        mock_popen.return_value = mock_proc

        executor = GeminiExecutor()
        await executor.execute(["-y", "-p", "test"])

        # Verify -y wasn't duplicated
        expected_cmd = ["gemini", "-y", "-p", "test"]
        args, kwargs = mock_popen.call_args
        assert args[0] == expected_cmd

    @patch("subprocess.Popen")
    @patch("asyncio.sleep", new_callable=AsyncMock)
    @pytest.mark.asyncio
    async def test_execute_with_yes_flag(self, mock_sleep, mock_popen):
        """Test that --yes flag prevents adding -y."""
        mock_proc = MagicMock()
        mock_popen.return_value = mock_proc

        executor = GeminiExecutor()
        await executor.execute(["--yes", "-p", "test"])

        # Verify -y wasn't added when --yes is present
        expected_cmd = ["gemini", "--yes", "-p", "test"]
        args, kwargs = mock_popen.call_args
        assert args[0] == expected_cmd

    def test_check_rate_limit_detection(self):
        """Test rate limit detection in text."""
        executor = GeminiExecutor()

        # Test positive cases
        assert executor.check_rate_limit("Error 429: Too many requests")
        assert executor.check_rate_limit("Quota exceeded for this request")
        assert executor.check_rate_limit("rateLimitExceeded in API call")
        assert executor.check_rate_limit("RESOURCE_EXHAUSTED error occurred")

        # Test negative case
        assert not executor.check_rate_limit("Normal response text")

    @patch("asyncio.get_event_loop")
    @patch("select.select")
    @patch("asyncio.sleep", new_callable=AsyncMock)
    @pytest.mark.asyncio
    async def test_monitor_process_rate_limit_detected(self, mock_sleep, mock_select, mock_loop):
        """Test monitoring process that detects rate limit."""
        # Mock event loop time
        mock_loop.return_value.time.side_effect = [0, 1, 2]  # Simulate time progression

        # Mock process
        mock_proc = MagicMock()
        mock_proc.poll.return_value = None  # Process still running
        mock_proc.stderr.readable.return_value = True
        mock_proc.stderr.readline.return_value = "Error 429: Quota exceeded\n"

        # Mock select to indicate stderr data available
        mock_select.return_value = ([mock_proc.stderr], [], [])

        executor = GeminiExecutor()
        rate_limit_detected, stderr_lines = await executor.monitor_process(mock_proc, monitor_time=5)

        assert rate_limit_detected is True
        assert len(stderr_lines) >= 1
        assert "429" in stderr_lines[0]

    @patch("asyncio.get_event_loop")
    @patch("select.select")
    @patch("asyncio.sleep", new_callable=AsyncMock)
    @pytest.mark.asyncio
    async def test_monitor_process_no_rate_limit(self, mock_sleep, mock_select, mock_loop):
        """Test monitoring process that completes normally."""
        # Mock event loop time
        mock_loop.return_value.time.side_effect = [0, 1, 2, 3, 4, 5, 6]

        # Mock process that completes
        mock_proc = MagicMock()
        mock_proc.poll.side_effect = [None, None, 0]  # Running, running, completed
        mock_proc.stderr.readable.return_value = True
        mock_proc.stderr.readline.return_value = ""  # No stderr output

        # Mock select to indicate no stderr data
        mock_select.return_value = ([], [], [])

        executor = GeminiExecutor()
        rate_limit_detected, stderr_lines = await executor.monitor_process(mock_proc, monitor_time=5)

        assert rate_limit_detected is False
        assert len(stderr_lines) == 0

    @pytest.mark.asyncio
    async def test_wait_completion_success(self):
        """Test successful process completion."""
        mock_proc = MagicMock()
        mock_proc.communicate.return_value = ("Response output", "")
        mock_proc.returncode = 0

        executor = GeminiExecutor()
        stdout, stderr = await executor.wait_completion(mock_proc)

        assert stdout == "Response output"
        assert stderr == ""
        mock_proc.communicate.assert_called_once_with(timeout=90)

    @pytest.mark.asyncio
    async def test_wait_completion_timeout(self):
        """Test process timeout handling."""
        mock_proc = MagicMock()
        mock_proc.communicate.side_effect = subprocess.TimeoutExpired("cmd", 90)

        executor = GeminiExecutor()

        with pytest.raises(subprocess.TimeoutExpired):
            await executor.wait_completion(mock_proc, timeout=90)

        mock_proc.terminate.assert_called_once()
</file>

<file path="tests/test_gemini/test_parser.py">
# this_file: tests/test_gemini/test_parser.py
"""Tests for the ResponseParser."""

from geminpy.gemini.parser import ResponseParser


class TestResponseParser:
    """Tests for the ResponseParser class."""

    def test_extract_clean_response_with_auth_noise(self):
        """Verify that auth-related lines are filtered out."""
        parser = ResponseParser()
        stdout = """Code Assist login required
Attempting to open authentication page
Otherwise navigate to: https://accounts.google.com/o/oauth2/auth
Waiting for authentication...
Authentication successful
[dotenv@1.0.0] Loaded configuration

This is the actual model response.
It spans multiple lines.
And contains the real content.
"""
        result = parser.extract_clean_response(stdout)
        expected = "This is the actual model response.\nIt spans multiple lines.\nAnd contains the real content."
        assert result == expected

    def test_extract_clean_response_no_auth_noise(self):
        """Verify that clean output without auth noise is returned as-is."""
        parser = ResponseParser()
        stdout = "Simple response without any authentication noise."
        result = parser.extract_clean_response(stdout)
        assert result == "Simple response without any authentication noise."

    def test_extract_clean_response_empty_input(self):
        """Verify that empty input returns None."""
        parser = ResponseParser()
        result = parser.extract_clean_response("")
        assert result is None

    def test_extract_clean_response_only_auth_noise(self):
        """Verify that input with only auth noise returns None."""
        parser = ResponseParser()
        stdout = """Code Assist login required
Attempting to open authentication page
Authentication successful
[dotenv@1.0.0] Loaded configuration
"""
        result = parser.extract_clean_response(stdout)
        assert result is None

    def test_extract_clean_response_mixed_content(self):
        """Verify that mixed content with auth noise in between is handled correctly."""
        parser = ResponseParser()
        stdout = """Here is some initial content.
Code Assist login required
Authentication successful
More content after auth.
[dotenv@1.0.0] Loaded configuration
Final content line.
"""
        result = parser.extract_clean_response(stdout)
        expected = "Here is some initial content.\nMore content after auth.\nFinal content line."
        assert result == expected

    def test_extract_clean_response_with_whitespace(self):
        """Verify that leading/trailing whitespace is handled correctly."""
        parser = ResponseParser()
        stdout = """
Code Assist login required
   This is the response.
   Another line.

"""
        result = parser.extract_clean_response(stdout)
        expected = "This is the response.\nAnother line."
        assert result == expected
</file>

<file path=".cursorrules">
## 1. Project Overview

This is a Python package called `geminpy` that appears to be a wrapper/automation tool for Google's Gemini CLI. The codebase includes:
- Old code that needs to be ported is in `work/gemini_wrapper.py`
- That code needs to be ported into `src/geminpy/` and suitably refactored.
- Modern Python packaging with Hatch build system
- Comprehensive testing and linting setup

## 2. Key Commands

### 2.1. Development

```bash
# Run tests
hatch run test

# Run tests with coverage
hatch run test-cov

# Type checking
hatch run type-check

# Linting
hatch run lint

# Format code
hatch run fmt

# Fix code issues (including unsafe fixes)
hatch run fix

# Run a single test
hatch run pytest tests/test_package.py::test_name
```

### 2.2. Environment-specific Commands

```bash
# Run all lint checks
hatch env run lint:all

# Build documentation
hatch env run docs:build

# Run CI tests (with XML coverage)
hatch env run ci:test
```

### 2.3. From .cursorrules - After Python changes run:

```bash
fd -e py -x autoflake {}; fd -e py -x pyupgrade --py311-plus {}; fd -e py -x ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x ruff format --respect-gitignore --target-version py311 {}; python -m pytest;
```

## 3. Architecture

### 3.1. Package Structure
- **src/geminpy/**: Main package source
  - `geminpy.py`: Core module
  - `__version__.py`: Dynamic version from VCS
- **work/**: Old `gemini_wrapper.py` 
- **tests/**: Test suite

### 3.2. Key Dependencies

- Build: Hatchling with hatch-vcs for version control
- Testing: pytest, pytest-cov, pytest-xdist, pytest-benchmark
- Linting: ruff (extensive rules), mypy (strict mode)
- Formatting: isort, pyupgrade, absolufy-imports
- Documentation: sphinx, sphinx-rtd-theme, myst-parser

### 3.3. Chrome Automation Component
The old `work/gemini_wrapper.py` script:
- Automates Google OAuth flow for Gemini CLI
- Manages Chrome for Testing installation
- Uses Playwright for browser automation
- Handles rate limiting with automatic fallback to flash model
- Stores settings in user data directory

We need to port this code into `src/geminpy/` and suitably refactor it.

## 4. Development Guidelines

- Use `uv pip`, never `pip`
- Use `python -m` when running code
- Write clear docstrings and descriptive names
- Use type hints in simplest form (list, dict, | for unions)
- Use f-strings and structural pattern matching
- Add verbose loguru-based logging
- For CLI scripts, use fire & rich
- Include `this_file` record near top of files
- Minimize confirmations, iterate gradually
- Handle failures gracefully with retries/fallbacks
- Modularize repeated logic into single-purpose functions

## 5. Configuration

### 5.1. Tool Configurations (pyproject.toml)
- **Pytest**: Configured with branch coverage, async support
- **Coverage**: Branch coverage enabled, parallel support
- **Mypy**: Strict mode with comprehensive type checking
- **Ruff**: Extensive linting rules covering security, style, complexity
- **Pre-commit**: Hook manager for code quality

### 5.2. Environment Support
- Python 3.10, 3.11, 3.12
- macOS-specific features in Chrome automation tool
- Git repository with VCS-based versioning

## 6. Old Gemini CLI OAuth Automation Wrapper

An automated OAuth wrapper for Google's `gemini` CLI tool on macOS that eliminates the need for manual authentication steps.

## 7. Overview

The `gemini_wrapper.py` script automates the complete Google OAuth flow for the `gemini` CLI by:

1. **Installing Chrome for Testing** if not available (using `@puppeteer/browsers`)
2. **Temporarily switching default browser** to Chrome for Testing (using `macdefaultbrowsy`)
3. **Launching Chrome** in remote debugging mode (port 9222)
4. **Running the `gemini` CLI** with your specified arguments
5. **Automating OAuth screens** via Playwright-over-CDP - selecting your account and clicking "Sign in"
6. **Restoring original browser** and optionally quitting Chrome when done

## 8. Key Features

### 8.1. 🔐 **Seamless Authentication**
- Automatically handles Google OAuth flow without manual intervention
- Supports specific user account selection via multiple configuration methods
- Remembers your preferred account across sessions

### 8.2. 🌐 **Smart Browser Management**
- Uses Chrome for Testing to avoid conflicts with your regular browser
- Automatically installs Chrome for Testing if needed
- Temporarily switches default browser for OAuth, then restores it

### 8.3. 🔄 **Rate Limit Handling**
- Detects API rate limits in real-time
- Automatically retries with `gemini-2.5-flash` model when rate limited
- Graceful failure handling with informative error messages

### 8.4. 📊 **Clean Response Extraction**
- Filters out authentication noise from gemini CLI output
- Returns clean model responses for programmatic use
- Preserves original CLI behavior for interactive use

## 9. Installation & Requirements

### 9.1. Prerequisites

**macOS only** - This tool requires macOS (Darwin) due to browser management dependencies.

#### 9.1.1. Install required tools:
```bash
# Install macdefaultbrowsy utility
brew install macdefaultbrowsy

# Install Playwright browsers (one-time setup)
playwright install chromium
```

#### 9.1.2. Dependencies (auto-installed via uv):
- `fire>=0.5.0` - CLI interface
- `playwright>=1.43.0` - Browser automation
- `requests>=2.31.0` - HTTP requests
- `platformdirs>=4.0.0` - Cross-platform directories
- `loguru>=0.7.0` - Logging

## 10. Usage

### 10.1. CLI Interface (Direct Replacement)

Use exactly like the regular `gemini` CLI, but with automatic OAuth:

```bash
# Ask a question
./gemini_wrapper.py -p "Explain Python decorators"

# Use specific model
./gemini_wrapper.py -m "gemini-pro" -p "Write a Python function"

# With verbose logging
./gemini_wrapper.py --verbose -p "Hello world"

# Quit Chrome when done
./gemini_wrapper.py --quit-chrome -p "What's the weather?"
```

### 10.2. Programmatic Interface

```python
from gemini_wrapper import ask

# Simple question-answer
response = ask("Explain quantum computing in simple terms")
print(response)

# With specific user account
response = ask("Generate Python code", user="myemail@gmail.com")
print(response)

# With debug logging
response = ask("Help with debugging", verbose=True)
print(response)
```

### 10.3. Advanced Usage

```python
import asyncio
from gemini_wrapper import call_gemini_cli

# Full control over gemini arguments
response = await call_gemini_cli(
    gemini_args=["-m", "gemini-pro", "-p", "Your prompt here"],
    user="specific@email.com",
    verbose=True,
    quit_chrome=True
)
```

## 11. User Account Configuration

The wrapper resolves your Google account in this priority order:

1. **`--user` CLI argument**: `./gemini_wrapper.py --user="you@gmail.com" -p "Hello"`
2. **`GEMINI_CLI_USER` environment variable**: `export GEMINI_CLI_USER="you@gmail.com"`
3. **Stored in settings.json**: Automatically saved from previous successful authentications
4. **First available account**: If none specified, uses the first Google account found

## 12. How It Works

### 12.1. Browser Automation Flow

1. **Setup Phase**:
   - Checks if Chrome for Testing is installed, installs if needed
   - Saves current default browser
   - Sets Chrome for Testing as temporary default

2. **Authentication Phase**:
   - Launches Chrome in debugging mode (port 9222)
   - Starts `gemini` CLI which opens OAuth URL in Chrome
   - Playwright connects to Chrome via Chrome DevTools Protocol (CDP)
   - Automatically clicks your account and "Sign in" button

3. **Execution Phase**:
   - Waits for OAuth success redirect
   - Monitors gemini process for completion or rate limits
   - Extracts clean response from mixed CLI output

4. **Cleanup Phase**:
   - Restores original default browser
   - Optionally quits Chrome for Testing
   - Returns clean response text

### 12.2. Rate Limit Handling

When the original request hits rate limits:
```
gemini-wrapper detects: "429" or "Quota exceeded" or "rateLimitExceeded"
↓
Automatically retries with: gemini -m "gemini-2.5-flash" [your-args]
↓
Returns response or fails gracefully
```

## 13. Old File Structure

```
work/
├── gemini_wrapper.py          # Main automation script
└── settings.json              # Auto-generated settings (Chrome path, user email)
```

## 14. Settings Storage

Settings are automatically stored in:
- **Path**: `~/Library/Application Support/com.twardoch.chrometesting/settings.json`
- **Contents**: Chrome for Testing executable path, preferred user email
- **Auto-managed**: No manual editing required

## 15. Troubleshooting

### 15.1. Common Issues

**"Chrome CDP did not become available"**
- Another Chrome instance may be running without `--remote-debugging-port`
- Check if port 9222 is blocked: `curl http://localhost:9222/json/version`
- Look at debug logs: `/tmp/gemini_chrome_stderr.log`

**"macdefaultbrowsy utility missing"**
```bash
brew install macdefaultbrowsy
```

**Authentication fails**
- Enable verbose mode: `--verbose` to see detailed OAuth flow
- Check screenshots saved to: `oauth_error*.png`
- Verify your Google account has access to Gemini

**Rate limits persist**
- The wrapper automatically tries `gemini-2.5-flash` on rate limits
- Wait a few minutes before retrying
- Check your Gemini API quota in Google Cloud Console

### 15.2. Debug Mode

Enable verbose logging to see the full automation process:

```bash
./gemini_wrapper.py --verbose -p "Your question"
```

This shows:
- Chrome installation and launch details
- Browser switching operations  
- OAuth flow step-by-step
- Gemini CLI output parsing
- Error details and screenshots

## 16. Security Notes

- **Browser isolation**: Uses Chrome for Testing, separate from your regular Chrome
- **Temporary access**: Only switches default browser during authentication
- **Local automation**: All OAuth automation happens locally via CDP
- **No credential storage**: No passwords or tokens are stored, only email preference

The wrapper provides a seamless, secure way to use Google's Gemini CLI without manual OAuth interruptions.

We need to port this code into `src/geminpy/` and suitably refactor it.


Be creative, diligent, critical, relentless & funny!
</file>

<file path=".gitignore">
__pycache__/
__version__.py
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_private
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
!?*.[Cc]ache/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!**/[Pp]ackages/build/
!Directory.Build.rsp
._*
.*crunch*.local.xml
.axoCover/*
.builds
.cache
.coverage
.coverage.*
.cr/personal
.DS_Store
.DS_Store?
.eggs/
.env
.fake/
.history/
.hypothesis/
.idea/
.installed.cfg
.ionide/
.localhistory/
.mfractor/
.nox/
.ntvs_analysis.dat
.paket/paket.exe
.pytest_cache/
.Python
.ruff_cache/
.sass-cache/
.Spotlight-V100
.tox/
.Trashes
.venv
.vs/
.vscode
.vscode/
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
*_autogen/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim_*.settings
*.bim.layout
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.cover
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.egg
*.egg-info/
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.png
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.py,cover
*.py[cod]
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.swo
*.swp
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
**/[Pp]ackages/*
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
*~
*$py.class
~$*
$tf/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
build/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
cover/
coverage.xml
coverage*.info
coverage*.json
coverage*.xml
csx/
CTestTestfile.cmake
develop-eggs/
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
downloads/
ecf/
eggs/
ehthumbs.db
env.bak/
env/
ENV/
FakesAssemblies/
FodyWeavers.xsd
Generated_Code/
Generated\ Files/
healthchecksdb
htmlcov/
install_manifest.txt
ipch/
lib/
lib64/
Makefile
MANIFEST
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nosetests.xml
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
parts/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
sdist/
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
Thumbs.db
UpgradeLog*.htm
UpgradeLog*.XML
var/
venv.bak/
venv/
VERSION.txt
wheels/
x64/
x86/
</file>

<file path="README.md">
# geminpy

**Automated OAuth wrapper for Google's Gemini CLI on macOS**

`geminpy` eliminates the manual authentication steps required by Google's `gemini` CLI tool. It automatically handles the entire OAuth flow - from browser management to account selection - letting you use Gemini programmatically without interruption.

## Why It Exists

Google's official `gemini` CLI requires manual OAuth authentication through a web browser each time you use it. This makes automation impossible and interrupts workflows. `geminpy` solves this by:

1. **Automating the OAuth dance** - No manual clicking through Google's authentication screens
2. **Managing browser contexts** - Uses isolated Chrome for Testing to avoid conflicts
3. **Handling rate limits gracefully** - Automatically retries with flash model when rate limited
4. **Providing clean outputs** - Filters authentication noise from responses

## What It Does

`geminpy` acts as a transparent wrapper around the official `gemini` CLI, adding automation capabilities:

- **Drop-in CLI replacement**: Use it exactly like the original `gemini` command
- **Programmatic API**: Call Gemini from Python code with `ask()` function
- **Multi-language support**: Handles OAuth pages in 9+ languages
- **Smart user detection**: Remembers your preferred Google account
- **Rate limit resilience**: Automatic fallback to `gemini-2.5-flash` when quota exceeded
- **Browser isolation**: Uses Chrome for Testing to avoid disrupting your main browser

## How It Works

### Technical Architecture

The package orchestrates several components to achieve seamless automation:

```
User Request → GeminiClient → Browser Setup → OAuth Automation → Gemini CLI → Response
                     ↓              ↓               ↓                ↓
              BrowserManager  ChromeManager  OAuthAutomator  GeminiExecutor
                     ↓              ↓               ↓                ↓
              macdefaultbrowsy  Chrome CDP    Playwright      subprocess
```

### Automation Flow

1. **Browser Preparation**

   - Installs Chrome for Testing if needed (via `@puppeteer/browsers`)
   - Saves current default browser
   - Temporarily switches to Chrome for Testing

2. **OAuth Automation**

   - Launches Chrome with remote debugging (`--remote-debugging-port=9222`)
   - Starts `gemini` CLI which opens OAuth URL
   - Playwright connects via Chrome DevTools Protocol
   - Automatically clicks your Google account
   - Detects and clicks sign-in button (multi-language, multi-strategy)
   - Waits for authentication success

3. **Execution & Monitoring**

   - Monitors gemini process output in real-time
   - Detects rate limits (429, quota exceeded, etc.)
   - Automatically retries with fallback model if needed
   - Extracts clean response from CLI output

4. **Cleanup**
   - Restores original default browser
   - Optionally quits Chrome
   - Returns pure response text

### Key Components

- **`browser.manager`**: Controls macOS default browser via `macdefaultbrowsy`
- **`browser.chrome`**: Manages Chrome for Testing installation and lifecycle
- **`browser.automation`**: Playwright-based OAuth flow automation
- **`gemini.client`**: Main orchestrator coordinating all components
- **`gemini.executor`**: Subprocess management with real-time monitoring
- **`gemini.parser`**: Response extraction and cleaning

## Installation

### Prerequisites

**macOS only** - Browser automation requires macOS-specific tools.

# Install geminpy

```bash
uv pip install geminpy
```

One-time setup: Install Playwright browsers

```bash
playwright install chromium
```

## Usage

### CLI Usage

Use exactly like the original `gemini` CLI:

```bash
# Ask a question
geminpy -p "Explain Python decorators"

# Use specific model with new shortcuts
geminpy -P -p "Write a Python function"  # Uses gemini-2.5-pro
geminpy -F -p "Quick question"           # Uses gemini-2.5-flash

# Traditional model selection still works
geminpy -m "gemini-pro" -p "Complex analysis"

# Enable verbose logging
geminpy --verbose -p "Debug this"

# Quit Chrome after completion
geminpy --quit-chrome -p "One-off query"
```

### Programmatic Usage

```python
from geminpy import ask

# Simple question-answer
response = ask("Explain quantum computing")
print(response)

# Async usage with full control
import asyncio
from geminpy import call_gemini_cli

async def main():
    response = await call_gemini_cli(
        gemini_args=["-m", "gemini-pro", "-p", "Your prompt"],
        user="your.email@gmail.com",
        verbose=True,
        quit_chrome=True
    )
    print(response)

asyncio.run(main())
```

## Configuration

### User Account Resolution

`geminpy` determines which Google account to use in this priority order:

1. **CLI argument**: `--user="you@gmail.com"`
2. **Environment variable**: `GEMINI_CLI_USER="you@gmail.com"`
3. **Stored settings**: From previous successful authentication
4. **First available**: Uses first Google account found

### Settings Storage

Settings are automatically persisted to:

```
~/Library/Application Support/com.twardoch.chrometesting/settings.json
```

Contains:

- Chrome for Testing executable path
- Last used Google account email

## Advanced Features

### Multi-Language OAuth Support

Detects sign-in buttons in multiple languages:

- English, Polish, French, German, Spanish
- Italian, Russian, Japanese, Chinese
- Falls back to attribute and style-based detection

### Rate Limit Handling

Automatic detection and retry logic:

```
Original request → Rate limit detected → Retry with gemini-2.5-flash → Final response
```

### Browser Isolation

- Uses dedicated Chrome for Testing instance
- Preserves your regular browser state
- No profile contamination
- Clean OAuth every time

## Troubleshooting

### Common Issues

**"Chrome CDP did not become available"**

- Check if port 9222 is available: `lsof -i :9222`
- Look at Chrome logs: `/tmp/gemini_chrome_stderr.log`

**"Could not find sign-in button"**

- Enable verbose mode: `--verbose`
- Check screenshots: `oauth_error.png`, `oauth_error_no_signin.png`
- Ensure your Google account has Gemini access

**"macdefaultbrowsy utility missing"**

```bash
brew install macdefaultbrowsy
```

### Debug Mode

Enable comprehensive logging:

```bash
geminpy --verbose -p "Your question"
```

Shows:

- Chrome installation progress
- Browser switching operations
- OAuth automation steps
- Gemini CLI interactions
- Response parsing details

## Development

### Project Structure

```
src/geminpy/
├── browser/          # Browser automation components
│   ├── automation.py # OAuth flow automation
│   ├── chrome.py     # Chrome for Testing management
│   └── manager.py    # Default browser control
├── gemini/           # Gemini CLI integration
│   ├── client.py     # Main orchestrator
│   ├── executor.py   # Process management
│   └── parser.py     # Response extraction
├── core/             # Core utilities
│   ├── config.py     # Configuration
│   ├── constants.py  # Constants
│   └── exceptions.py # Custom exceptions
├── utils/            # Utilities
│   ├── platform.py   # Platform checks
│   └── storage.py    # Settings persistence
├── api.py            # Public API
└── cli.py            # CLI interface
```

### Running Tests

```bash
# Run all tests
uvx hatch run test

# Run with coverage
uvx hatch run test-cov

# Type checking
uvx hatch run type-check

# Linting
uvx hatch run lint
```

### Building

```bash
# Build package
uvx hatch build

# Install locally
uv pip install --system -e .
```

## Security

- **No credential storage** - Only stores email preference
- **Local automation only** - All OAuth happens on your machine
- **Temporary browser access** - Restored after each use
- **Process isolation** - Chrome runs in separate process

## Requirements

- **Platform**: macOS (Darwin) only
- **Python**: 3.10, 3.11, or 3.12
- **System**: `macdefaultbrowsy` utility
- **Browser**: Chrome for Testing (auto-installed)

## License

MIT License - see LICENSE file for details.
</file>

<file path="pyproject.toml">
# this_file: pyproject.toml
#==============================================================================
# GEMINPY PACKAGE CONFIGURATION
# This pyproject.toml defines the package metadata, dependencies, build system,
# and development environment for the geminpy package.
#==============================================================================

#------------------------------------------------------------------------------
# PROJECT METADATA
# Core package information used by PyPI and package managers.
#------------------------------------------------------------------------------
[project]
name = 'geminpy' # Package name on PyPI
description = 'Automated OAuth wrapper for Google Gemini CLI on macOS' # Short description
readme = 'README.md' # Path to README file
requires-python = '>=3.10' # Minimum Python version
keywords = [
] # Keywords for PyPI search
dynamic = ["version"] # Fields set dynamically at build time

# PyPI classifiers for package categorization
classifiers = [
    'Development Status :: 4 - Beta', # Package maturity level
    'Programming Language :: Python',
    'Programming Language :: Python :: 3.10',
    'Programming Language :: Python :: 3.11',
    'Programming Language :: Python :: 3.12',
    'Programming Language :: Python :: Implementation :: CPython',
    'Programming Language :: Python :: Implementation :: PyPy',
    'Operating System :: OS Independent',
    'License :: OSI Approved :: MIT License',
    'Intended Audience :: Developers',
]

dependencies = [
    "fire>=0.5.0",
    "playwright>=1.43.0",
    "requests>=2.31.0",
    "platformdirs>=4.0.0",
    "loguru>=0.7.0",
    "rich>=13.0.0",
]

# Author information
[[project.authors]]
name = 'Adam Twardoch'
email = 'adam+github@twardoch.com'

# License information
[project.license]
text = 'MIT'

# Project URLs
[project.urls]
Documentation = 'https://github.com/twardoch/geminpy#readme'
Issues = 'https://github.com/twardoch/geminpy/issues'
Source = 'https://github.com/twardoch/geminpy'

#------------------------------------------------------------------------------
# OPTIONAL DEPENDENCIES
# Additional dependencies for optional features, development, and testing.
#------------------------------------------------------------------------------
[project.optional-dependencies]

# Development tools
dev = [
    'pre-commit>=4.1.0', # Pre-commit hook manager - Keep pre-commit as is, update if newer pre-commit version is required
    'ruff>=0.9.7', # Linting and formatting - Keep ruff as is, update if newer ruff version is required
    'mypy>=1.15.0', # Type checking - Keep mypy as is, update if newer mypy version is required
    'absolufy-imports>=0.3.1', # Convert relative imports to absolute - Keep absolufy-imports as is, update if newer absolufy-imports version is required
    'pyupgrade>=3.19.1', # Upgrade Python syntax - Keep pyupgrade as is, update if newer pyupgrade version is required
    'isort>=6.0.1', # Sort imports - Keep isort as is, update if newer isort version is required
]

# Testing tools and frameworks
test = [
    'pytest>=8.3.4', # Testing framework - Keep pytest as is, update if newer pytest version is required
    'pytest-cov>=6.0.0', # Coverage plugin for pytest - Keep pytest-cov as is, update if newer pytest-cov version is required
    'pytest-xdist>=3.6.1', # Parallel test execution - Keep pytest-xdist as is, update if newer pytest-xdist version is required
    'pytest-benchmark[histogram]>=5.1.0', # Benchmarking plugin - Keep pytest-benchmark as is, update if newer pytest-benchmark version is required
    'pytest-asyncio>=0.25.3', # Async test support - Keep pytest-asyncio as is, update if newer pytest-asyncio version is required
    'coverage[toml]>=7.6.12',
]

docs = [
    "sphinx>=7.2.6",
    "sphinx-rtd-theme>=2.0.0",
    "sphinx-autodoc-typehints>=2.0.0",
    "myst-parser>=3.0.0", # Markdown support in Sphinx
]

# All optional dependencies combined
all = [
]

#------------------------------------------------------------------------------
# COMMAND-LINE SCRIPTS
# Entry points for command-line executables installed with the package.
#------------------------------------------------------------------------------
[project.scripts]
geminpy = "geminpy.cli:main"

#------------------------------------------------------------------------------
# BUILD SYSTEM CONFIGURATION
# Defines the tools required to build the package and the build backend.
#------------------------------------------------------------------------------
[build-system]
# Hatchling is a modern build backend for Python packaging
# hatch-vcs integrates with version control systems for versioning
requires = [
    'hatchling>=1.27.0', # Keep hatchling as is, update if newer hatchling version is required
    'hatch-vcs>=0.4.0', # Keep hatch-vcs as is, update if newer hatch-vcs version is required
]
build-backend = 'hatchling.build' # Specifies Hatchling as the build backend


#------------------------------------------------------------------------------
# HATCH BUILD CONFIGURATION
# Configures the build process, specifying which packages to include and
# how to handle versioning.
#------------------------------------------------------------------------------
[tool.hatch.build]
# Include package data files
include = [
    "src/geminpy/py.typed", # For better type checking support
    "src/geminpy/data/**/*", # Include data files if any

]
exclude = ["**/__pycache__", "**/.pytest_cache", "**/.mypy_cache"]

[tool.hatch.build.targets.wheel]
packages = ["src/geminpy"]
reproducible = true

[tool.hatch.build.targets.sdist]
include = [
    "src/geminpy/**/*.py",
    "README.md",
    "LICENSE",
    "pyproject.toml",
]

# Version control system hook configuration
# Automatically updates the version file from git tags
[tool.hatch.build.hooks.vcs]
version-file = "src/geminpy/__version__.py"

# Version source configuration
[tool.hatch.version]
source = 'vcs' # Get version from git tags or other VCS info

# Metadata handling configuration
[tool.hatch.metadata]
allow-direct-references = true # Allow direct references in metadata (useful for local dependencies)


#------------------------------------------------------------------------------
# DEVELOPMENT ENVIRONMENTS

[tool.hatch.envs.default]
features = ['dev', 'test', 'all']
dependencies = [
]

# Commands available in the default environment
[tool.hatch.envs.default.scripts]
# Run tests with optional arguments
test = 'pytest {args:tests}'
# Run tests with coverage reporting
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/geminpy --cov=tests {args:tests}"
# Run type checking
type-check = "mypy src/geminpy tests"
# Run linting and formatting
lint = ["ruff check src/geminpy tests", "ruff format --respect-gitignore src/geminpy tests"]
# Format and fix style issues
fmt = ["ruff format --respect-gitignore src/geminpy tests", "ruff check --fix src/geminpy tests"]
fix = ["ruff check --fix --unsafe-fixes src/geminpy tests", "ruff format --respect-gitignore src/geminpy tests"]

# Matrix configuration to test across multiple Python versions

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

#------------------------------------------------------------------------------
# SPECIALIZED ENVIRONMENTS
# Additional environments for specific development tasks.
#------------------------------------------------------------------------------

# Dedicated environment for linting and code quality checks
[tool.hatch.envs.lint]
detached = true # Create a separate, isolated environment
features = ['dev'] # Use dev extras  dependencies 

# Linting environment commands
[tool.hatch.envs.lint.scripts]
# Type checking with automatic type installation
typing = "mypy --install-types --non-interactive {args:src/geminpy tests}"
# Check style and format code
style = ["ruff check {args:.}", "ruff format --respect-gitignore {args:.}"]
# Format and fix style issues
fmt = ["ruff format --respect-gitignore {args:.}", "ruff check --fix {args:.}"]
fix = ["ruff check --fix --unsafe-fixes {args:.}", "ruff format --respect-gitignore {args:.}"]
# Run all ops
all = ["style", "typing", "fix"]

# Dedicated environment for testing
[tool.hatch.envs.test]
features = ['test'] # Use test extras as dependencies

# Testing environment commands
[tool.hatch.envs.test.scripts]
# Run tests in parallel
test = "python -m pytest -n auto {args:tests}"
# Run tests with coverage in parallel
test-cov = "python -m pytest -n auto --cov-report=term-missing --cov-config=pyproject.toml --cov=src/geminpy --cov=tests {args:tests}"
# Run benchmarks
bench = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only"
# Run benchmarks and save results
bench-save = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only --benchmark-json=benchmark/results.json"

# Documentation environment
[tool.hatch.envs.docs]
features = ['docs']

# Documentation environment commands
[tool.hatch.envs.docs.scripts]
build = "sphinx-build -b html docs/source docs/build"

# GitHub Actions workflow configuration
[tool.hatch.envs.ci]
features = ['test']


[tool.hatch.envs.ci.scripts]
test = "pytest --cov=src/geminpy --cov-report=xml"


#------------------------------------------------------------------------------
# CODE QUALITY TOOLS
# Configuration for linting, formatting, and code quality enforcement.
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# COVERAGE CONFIGURATION
# Settings for test coverage measurement and reporting.
#------------------------------------------------------------------------------

# Path mapping for coverage in different environments
[tool.coverage.paths]
geminpy = ["src/geminpy", "*/geminpy/src/geminpy"]
tests = ["tests", "*/geminpy/tests"]

# Coverage report configuration
[tool.coverage.report]
# Lines to exclude from coverage reporting
exclude_lines = [
    'no cov', # Custom marker to skip coverage
    'if __name__ == .__main__.:', # Script execution guard
    'if TYPE_CHECKING:', # Type checking imports and code
    'pass', # Empty pass statements
    'raise NotImplementedError', # Unimplemented method placeholders
    'raise ImportError', # Import error handling
    'except ImportError', # Import error handling
    'except KeyError', # Common error handling
    'except AttributeError', # Common error handling
    'except NotImplementedError', # Common error handling
]

[tool.coverage.run]
source_pkgs = ["src/geminpy", "tests"]
branch = true # Measure branch coverage (if/else statements)
parallel = true # Support parallel test execution
omit = [
    "src/geminpy/__about__.py",
]

#------------------------------------------------------------------------------
# MYPY CONFIGURATION
# Configuration for type checking with mypy.
#------------------------------------------------------------------------------

[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true

[[tool.mypy.overrides]]
module = ["tests.*"]
disallow_untyped_defs = false
disallow_incomplete_defs = false

#------------------------------------------------------------------------------
# PYTEST CONFIGURATION
# Configuration for pytest, including markers, options, and benchmark settings.
#------------------------------------------------------------------------------

[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase"
asyncio_mode = "auto"
asyncio_default_fixture_loop_scope = "function"
console_output_style = "progress"
filterwarnings = ["ignore::DeprecationWarning", "ignore::UserWarning"]
log_cli = true
log_cli_level = "INFO"
markers = [
    "benchmark: marks tests as benchmarks (select with '-m benchmark')",
    "unit: mark a test as a unit test",
    "integration: mark a test as an integration test",
    "permutation: tests for permutation functionality", 
    "parameter: tests for parameter parsing",
    "prompt: tests for prompt parsing",
]
norecursedirs = [
    ".*",
    "build",
    "dist", 
    "venv",
    "__pycache__",
    "*.egg-info",
    "_private",
]
python_classes = ["Test*"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
testpaths = ["tests"]

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",    # Minimum time
    "max",    # Maximum time
    "mean",   # Mean time
    "stddev", # Standard deviation
    "median", # Median time
    "iqr",    # Inter-quartile range
    "ops",    # Operations per second
    "rounds", # Number of rounds
]

#------------------------------------------------------------------------------
# RUFF CONFIGURATION
# Configuration for Ruff, including linter and formatter settings.
#------------------------------------------------------------------------------ 

# Ruff linter and formatter configuration
[tool.ruff]
target-version = "py310"
line-length = 120

# Linting rules configuration
[tool.ruff.lint]
# Rule sets to enable, organized by category
select = [
    # flake8 plugins and extensions
    'A', # flake8-builtins: checks for shadowed builtins
    'ARG', # flake8-unused-arguments: checks for unused function arguments
    'ASYNC', # flake8-async: checks for async/await issues
    'B', # flake8-bugbear: finds likely bugs and design problems
    'C', # flake8-comprehensions: helps write better list/dict comprehensions
    'DTZ', # flake8-datetimez: checks for datetime timezone issues
    'E', # pycodestyle errors: PEP 8 style guide errors
    'EM', # flake8-errmsg: checks for better error messages
    'F', # pyflakes: detects various errors
    'FBT', # flake8-boolean-trap: checks for boolean traps in function signatures
    'I', # isort: sorts imports
    'ICN', # flake8-import-conventions: checks for import conventions
    'ISC', # flake8-implicit-str-concat: checks for implicit string concatenation
    'LOG', # flake8-logging: checks for logging issues
    'N', # pep8-naming: checks naming conventions
    'PLC', # pylint convention: checks for convention issues
    'PLE', # pylint error: checks for errors
    'PLR', # pylint refactor: suggests refactors
    'PLW', # pylint warning: checks for suspicious code
    'PT', # flake8-pytest-style: checks pytest-specific style
    'PTH', # flake8-use-pathlib: checks for stdlib path usage vs pathlib
    'PYI', # flake8-pyi: checks stub files
    'RET', # flake8-return: checks return statement consistency
    'RSE', # flake8-raise: checks raise statements
    'RUF', # Ruff-specific rules
    'S', # flake8-bandit: checks for security issues
    'SIM', # flake8-simplify: checks for code simplification opportunities
    'T', # flake8-print: checks for print statements
    'TCH', # flake8-type-checking: helps with type-checking
    'TID', # flake8-tidy-imports: checks for tidy import statements
    'UP', # pyupgrade: checks for opportunities to use newer Python features
    'W', # pycodestyle warnings: PEP 8 style guide warnings
    'YTT', # flake8-2020: checks for misuse of sys.version or sys.version_info

]
# Rules to ignore (with reasons)
ignore = [
    'B027', # Empty method in abstract base class - sometimes needed for interfaces
    'C901', # Function is too complex - sometimes complexity is necessary
    'FBT003', # Boolean positional argument in function definition - sometimes unavoidable
    'PLR0911', # Too many return statements - sometimes needed for readability
    'PLR0912', # Too many branches - sometimes needed for complex logic
    'PLR0913', # Too many arguments - sometimes needed in APIs
    'PLR0915', # Too many statements - sometimes needed for comprehensive functions
    'PLR1714', # Consider merging multiple comparisons - sometimes less readable
    'PLW0603', # Using the global statement - sometimes necessary
    'PT013', # Pytest explicit test parameter - sometimes clearer
    'PTH123', # Path traversal - sometimes needed
    'PYI056', # Calling open() in pyi file - sometimes needed in type stubs
    'S105', # Possible hardcoded password - often false positives
    'S106', # Possible hardcoded password - often false positives
    'S107', # Possible hardcoded password - often false positives
    'S110', # try-except-pass - sometimes valid for suppressing exceptions
    'SIM102'
    # Nested if statements - sometimes more readable than combined conditions
]
# Rules that should not be automatically fixed
unfixable = [
    'F401', # Don't automatically remove unused imports - may be needed later

]
# Configure exclude to ignore specific directories
exclude = [".git", ".venv", "venv", "dist", "build"]

# isort configuration within Ruff
[tool.ruff.lint.isort]
known-first-party = ['geminpy'] # Treat as first-party imports for sorting

# flake8-tidy-imports configuration within Ruff
[tool.ruff.lint.flake8-tidy-imports]
ban-relative-imports = 'all' # Ban all relative imports for consistency

# Per-file rule exceptions
[tool.ruff.lint.per-file-ignores]
# Tests can use magic values, assertions, and relative imports
'tests/**/*' = [
    'PLR2004', # Allow magic values in tests for readability
    'S101', # Allow assertions in tests
    'TID252'
    # Allow relative imports in tests for convenience
]
</file>

</files>
