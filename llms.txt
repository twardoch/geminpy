This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    push.yml
    release.yml
.specstory/
  history/
    2025-06-27_23-09-analyze-gemini-wrapper-py-for-readme.md
    2025-06-27_23-17-untitled.md
  .gitignore
src/
  geminpy/
    browser/
      __init__.py
      automation.py
      chrome.py
      manager.py
    core/
      __init__.py
      config.py
      constants.py
      exceptions.py
    gemini/
      __init__.py
      client.py
      executor.py
      parser.py
    utils/
      __init__.py
      logging.py
      platform.py
      storage.py
    __init__.py
    __main__.py
    api.py
    cli.py
    geminpy.py
tests/
  test_browser/
    test_automation.py
    test_chrome.py
    test_manager.py
  test_gemini/
    test_client.py
    test_executor.py
    test_parser.py
  test_utils/
    test_platform.py
    test_storage.py
  conftest.py
  test_api.py
  test_cli.py
  test_package.py
work/
  gemini_wrapper.py
.cursorindexingignore
.cursorrules
.gitignore
.pre-commit-config.yaml
AGENTS.md
CHANGELOG.md
CLAUDE.md
LICENSE
package.toml
pyproject.toml
README.md
TODO.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".specstory/history/2025-06-27_23-17-untitled.md">
<!-- Generated by SpecStory -->

# Untitled (2025-06-28 01:17:10)

_**User**_

@TODO.md ANalyze @llms.txt and write CHANGELOG.md of what we've done and update @TODO.md and then continue implementing

---

_**Assistant**_



---
</file>

<file path="src/geminpy/browser/__init__.py">
# this_file: src/geminpy/browser/__init__.py
"""Browser management and automation components."""

from .automation import OAuthAutomator
from .chrome import ChromeManager, ChromeTestingManager
from .manager import BrowserManager

__all__ = ["OAuthAutomator", "ChromeManager", "ChromeTestingManager", "BrowserManager"]
</file>

<file path="src/geminpy/browser/automation.py">
# this_file: src/geminpy/browser/automation.py
"""OAuth flow automation using Playwright."""

import asyncio
import os
import re

import requests
from loguru import logger
from playwright.async_api import Page, Playwright, async_playwright

from ..core.constants import CDP_VERSION_URL, OAUTH_SIGNIN_PATTERN, SUCCESS_PATTERN
from ..core.exceptions import AuthenticationError


class OAuthAutomator:
    """Handles OAuth flow automation using Playwright."""

    def __init__(self, debug_port: int = 9222):
        """Initialize with Chrome debug port."""
        self.debug_port = debug_port

    async def _connect_playwright(self) -> tuple[Playwright, Page]:
        """Connect to Chrome via CDP and return playwright instance and OAuth page."""
        logger.debug("Connecting to Chrome over CDP...")
        info = requests.get(CDP_VERSION_URL.format(port=self.debug_port), timeout=10).json()
        ws_url = info["webSocketDebuggerUrl"]
        pw = await async_playwright().start()
        browser = await pw.chromium.connect_over_cdp(ws_url)

        if not browser.contexts:
            raise AuthenticationError(
                "No browser contexts found. Is Chrome running correctly?"
            )
        context = browser.contexts[0]

        # Find the OAuth page
        logger.debug("Searching for Google OAuth page among open tabs...")
        for _ in range(8):  # Reduced from 15 to 8 seconds
            for page in context.pages:
                try:
                    url = page.url
                    if "accounts.google.com" in url:
                        logger.debug(f"Found potential OAuth page: {url}")
                        await page.bring_to_front()
                        return pw, page
                except Exception as e:
                    logger.debug(f"Could not check a page, it might be closed: {e}")
            logger.debug("OAuth page not found yet, retrying...")
            await asyncio.sleep(1)

        raise AuthenticationError("Could not find a Google Accounts page to automate.")

    async def _wait_for_url(
        self, page: Page, pattern: re.Pattern, timeout: int = 120
    ) -> None:
        """Wait for page URL to match pattern."""
        await page.wait_for_url(pattern, wait_until="load", timeout=timeout * 1000)

    async def run_oauth_flow(self, user_email: str | None) -> None:
        """Execute the complete OAuth flow."""
        pw, page = await self._connect_playwright()
        try:
            logger.debug(f"Automating page: {page.url}")

            # Wait for page to be ready
            await page.wait_for_load_state(
                "domcontentloaded", timeout=15000
            )  # Reduced from 20s
            await asyncio.sleep(1)  # Reduced from 2 seconds

            # Step 1: Click the account
            if user_email:
                logger.debug(f"Looking for specific account: {user_email}")
                # Try direct data-identifier selection first
                account_locator = page.locator(f'[data-identifier="{user_email}"]')

                if await account_locator.count() == 0:
                    logger.debug(
                        f"Specific account '{user_email}' not found by data-identifier, trying by text content"
                    )
                    # Fallback to searching by text content in links
                    account_locator = page.get_by_role(
                        "link", name=re.compile(user_email, re.IGNORECASE)
                    )

                    if await account_locator.count() == 0:
                        logger.debug(
                            f"Specific account '{user_email}' not found, using first available account"
                        )
                        # Use first element with data-identifier
                        account_locator = page.locator("[data-identifier]").first
            else:
                logger.debug("Looking for first available account")
                # Use first element with data-identifier
                account_locator = page.locator("[data-identifier]").first

            account_count = await account_locator.count()
            if account_count == 0:
                await page.screenshot(path="oauth_error_no_account.png")
                target_desc = f"'{user_email}'" if user_email else "any account"
                raise AuthenticationError(
                    f"Could not find {target_desc} using direct selection."
                )

            logger.debug(f"Account found ({account_count} matches), clicking it...")
            await account_locator.click()

            # Step 2: Click the sign-in button
            logger.debug("Waiting for the approval page to load...")
            await page.wait_for_load_state(
                "domcontentloaded", timeout=10000
            )  # Reduced from 15s
            await asyncio.sleep(1)  # Reduced from 2 seconds

            logger.debug("Looking for sign-in button...")
            sign_in_locator = page.get_by_role(
                "button", name=re.compile("Sign in|Continue", re.IGNORECASE)
            )

            if await sign_in_locator.count() == 0:
                await page.screenshot(path="oauth_error_no_signin.png")
                raise AuthenticationError(
                    "Could not find 'Sign in' or 'Continue' button using get_by_role."
                )

            logger.debug("Sign-in button found, clicking it...")
            await sign_in_locator.first.click()

            # Step 3: Wait for success and close tab
            logger.debug("Waiting for success redirect...")
            await self._wait_for_url(page, re.compile(SUCCESS_PATTERN), timeout=60)
            logger.debug("OAuth flow completed successfully ✔")
            logger.debug(f"Success page reached: {page.url}")

            logger.debug("Closing success tab...")
            await page.close()
            logger.debug("Success tab closed successfully")

        except Exception as e:
            logger.error(f"An error occurred during OAuth automation: {e}")
            await page.screenshot(path="oauth_error.png")
            logger.debug("Saved a screenshot to oauth_error.png for debugging.")
            raise
        finally:
            logger.debug("Stopping Playwright.")
            await pw.stop()


class UserResolver:
    """Resolves the target user email from multiple sources."""

    @staticmethod
    def resolve_user_email(
        cli_user: str | None = None, settings_getter=None
    ) -> str | None:
        """Resolve user email from multiple sources in priority order."""
        # 1. --user command line argument
        if cli_user:
            logger.debug(f"Using user from CLI argument: {cli_user}")
            return cli_user

        # 2. GEMINI_CLI_USER environment variable
        env_user = os.environ.get("GEMINI_CLI_USER")
        if env_user:
            logger.debug(f"Using user from GEMINI_CLI_USER env var: {env_user}")
            return env_user

        # 3. gemini_cli_user in settings.json
        if settings_getter:
            stored_user = settings_getter()
            if stored_user:
                logger.debug(f"Using user from settings.json: {stored_user}")
                return stored_user

        # 4. No specific user - will use first available account
        logger.debug("No specific user configured - will use first available account")
        return None
</file>

<file path="src/geminpy/browser/chrome.py">
# this_file: src/geminpy/browser/chrome.py
"""Chrome for Testing management and process control."""

import asyncio
import subprocess
import time
from pathlib import Path

import requests
from loguru import logger

from ..core.config import AppConfig, ChromeConfig
from ..core.constants import BrowserID, CDP_VERSION_URL
from ..core.exceptions import ChromeError, ChromeInstallationError
from ..utils.storage import SettingsManager


class ChromeTestingManager:
    """Manages Chrome for Testing installation and configuration."""

    def __init__(self, config: AppConfig):
        """Initialize with app configuration."""
        self.config = config
        self.settings = SettingsManager(config.settings_dir)

    def get_stored_path(self) -> Path | None:
        """Get the stored Chrome for Testing executable path."""
        path_str = self.settings.get("chrome_testing_path")
        return Path(path_str) if path_str else None

    def set_stored_path(self, path: Path) -> None:
        """Store the Chrome for Testing executable path."""
        self.settings.set("chrome_testing_path", str(path))

    def get_stored_user(self) -> str | None:
        """Get the stored gemini CLI user email."""
        return self.settings.get("gemini_cli_user")

    def set_stored_user(self, user_email: str) -> None:
        """Store the gemini CLI user email."""
        self.settings.set("gemini_cli_user", user_email)

    def install(self) -> Path:
        """Install Chrome for Testing and return the executable path."""
        logger.debug("Installing Chrome for Testing...")

        cmd = [
            "npx",
            "-y",
            "@puppeteer/browsers",
            "install",
            "chrome@stable",
            "--platform",
            "mac",
            "--path",
            "/Applications",
            "--quiet",
        ]

        logger.debug(f"Running: {' '.join(cmd)}")
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)

        # Parse the output to find the executable path
        executable_path = None
        for line in result.stdout.strip().split("\n"):
            line = line.strip()
            if line and not line.startswith("Downloading"):
                parts = line.split(" ", 1)
                if len(parts) == 2:
                    executable_path = parts[1]
                    break

        if not executable_path:
            raise ChromeInstallationError(
                f"Could not parse Chrome for Testing path from output: {result.stdout}"
            )

        path = Path(executable_path)
        if not path.exists():
            raise ChromeInstallationError(
                f"Chrome for Testing executable not found at: {executable_path}"
            )

        logger.debug(f"Chrome for Testing installed at: {executable_path}")
        self.set_stored_path(path)
        return path

    def ensure_available(self) -> Path:
        """Ensure Chrome for Testing is available and return the executable path."""
        from .manager import BrowserManager

        # Check if we already have the path stored
        stored_path = self.get_stored_path()
        if stored_path and stored_path.exists():
            logger.debug(f"Using existing Chrome for Testing: {stored_path}")
            return stored_path

        # Check if 'testing' browser is available in macdefaultbrowser
        available_browsers = BrowserManager.get_available_browsers()
        if BrowserID.TESTING not in available_browsers:
            logger.debug(
                f"'{BrowserID.TESTING}' browser not found in available browsers: {available_browsers}"
            )
            logger.debug("Installing Chrome for Testing...")
            return self.install()
        else:
            logger.debug(f"'{BrowserID.TESTING}' browser found in available browsers")
            stored_path = self.get_stored_path()
            if stored_path and stored_path.exists():
                return stored_path
            else:
                logger.debug("Chrome for Testing path not found, reinstalling...")
                return self.install()


class ChromeManager:
    """Manages Chrome for Testing processes."""

    def __init__(self, config: ChromeConfig):
        """Initialize with Chrome configuration."""
        self.config = config

    def launch(self, executable_path: Path) -> subprocess.Popen:
        """Launch Chrome for Testing with CDP enabled."""
        args = [
            str(executable_path),
            f"--remote-debugging-port={self.config.debug_port}",
            f"--user-data-dir={self.config.user_data_dir}",
            "--no-first-run",
            "--no-default-browser-check",
            "--disable-popup-blocking",
            "--disable-web-security",
            "--disable-features=VizDisplayCompositor",
            "about:blank",
        ]

        logger.debug(f"exec: {' '.join(args)}")

        # Capture stderr for debugging
        stderr_file = "/tmp/gemini_chrome_stderr.log"
        with open(stderr_file, "w") as f:
            f.write(f"Chrome for Testing launch command: {' '.join(args)}\n")
            f.write("=" * 50 + "\n")

        logger.debug(f"Chrome stderr will be logged to: {stderr_file}")

        return subprocess.Popen(
            args, stdout=subprocess.DEVNULL, stderr=open(stderr_file, "a")
        )

    def is_cdp_ready(self) -> bool:
        """Check if Chrome CDP endpoint is ready."""
        try:
            response = requests.get(
                CDP_VERSION_URL.format(port=self.config.debug_port), timeout=1
            )
            return response.status_code == 200
        except requests.RequestException:
            return False

    async def wait_for_cdp(self, timeout: int = 20) -> None:
        """Wait for Chrome's CDP to be ready."""
        logger.debug("Waiting for Chrome CDP port to open...")
        start_time = time.time()
        retry_count = 0
        max_retries = 20

        while time.time() - start_time < timeout:
            retry_count += 1
            try:
                response = requests.get(
                    CDP_VERSION_URL.format(port=self.config.debug_port), timeout=1
                )
                if response.status_code == 200:
                    logger.debug(f"Chrome CDP is ready after {retry_count} attempts.")
                    return
                else:
                    logger.debug(
                        f"retry {retry_count}/{max_retries} … HTTP {response.status_code}"
                    )
            except requests.ConnectionError:
                logger.debug(f"retry {retry_count}/{max_retries} … connection refused")
            except requests.RequestException as e:
                logger.debug(
                    f"retry {retry_count}/{max_retries} … {type(e).__name__}: {e}"
                )

            await asyncio.sleep(1)

        error_msg = f"""
ERROR: Chrome never opened port {self.config.debug_port} after {retry_count} attempts.

Possible causes:
• Another Chrome instance was already running without --remote-debugging-port
• A firewall is blocking localhost:{self.config.debug_port}
• Chrome failed to start (check /tmp/gemini_chrome_stderr.log)

Try manually:
  curl http://localhost:{self.config.debug_port}/json/version

You should get a JSON response with 'webSocketDebuggerUrl'.
"""
        logger.error(error_msg.strip())
        raise ChromeError(
            f"Chrome CDP did not become available after {retry_count} attempts."
        )
</file>

<file path="src/geminpy/browser/manager.py">
# this_file: src/geminpy/browser/manager.py
"""Manages default browser settings on macOS."""

import subprocess

from loguru import logger

from ..utils.platform import require_command


class BrowserManager:
    """Manages default browser settings on macOS."""

    @staticmethod
    def _require_defaultbrowser() -> None:
        """Ensure macdefaultbrowser utility is available."""
        require_command(
            "macdefaultbrowser", "Install with: brew install macdefaultbrowser"
        )

    @classmethod
    def get_current_default(cls) -> str:
        """Get current default browser identifier."""
        cls._require_defaultbrowser()
        result = subprocess.run(
            ["macdefaultbrowser"], capture_output=True, text=True, check=True
        )
        for line in result.stdout.splitlines():
            line = line.strip()
            if line and line.startswith("* "):
                return line[2:]
        return (
            result.stdout.splitlines()[0].strip() if result.stdout.splitlines() else ""
        )

    @classmethod
    def get_available_browsers(cls) -> list[str]:
        """List all available browser identifiers."""
        cls._require_defaultbrowser()
        result = subprocess.run(
            ["macdefaultbrowser"], capture_output=True, text=True, check=True
        )
        browsers = []
        for line in result.stdout.splitlines():
            line = line.strip()
            if line:
                browsers.append(line[2:] if line.startswith("* ") else line)
        return browsers

    @classmethod
    def set_default(cls, browser_id: str) -> None:
        """Set the default browser."""
        cls._require_defaultbrowser()
        logger.debug(f"Setting default browser to: {browser_id}")
        subprocess.run(["macdefaultbrowser", browser_id], check=True)
</file>

<file path="src/geminpy/core/__init__.py">
# this_file: src/geminpy/core/__init__.py
"""Core components for Geminpy."""

from .config import AppConfig, ChromeConfig, GeminiConfig
from .constants import AuthStatus, BrowserID, RateLimitIndicators
from .exceptions import (
    AuthenticationError,
    BrowserManagementError,
    ChromeError,
    ChromeInstallationError,
    GeminiError,
    PlatformError,
    RateLimitError,
)

__all__ = [
    "AppConfig",
    "ChromeConfig", 
    "GeminiConfig",
    "AuthStatus",
    "BrowserID",
    "RateLimitIndicators",
    "AuthenticationError",
    "BrowserManagementError",
    "ChromeError",
    "ChromeInstallationError",
    "GeminiError",
    "PlatformError",
    "RateLimitError",
]
</file>

<file path="src/geminpy/core/config.py">
# this_file: src/geminpy/core/config.py
"""Configuration management for Geminpy."""

from dataclasses import dataclass, field
from pathlib import Path

from platformdirs import user_data_dir


@dataclass
class ChromeConfig:
    """Chrome for Testing configuration."""

    executable_path: Path | None = None
    debug_port: int = 9222
    user_data_dir: Path = Path("/tmp/chrome_gemini_automation")
    quit_chrome: bool = False


@dataclass
class GeminiConfig:
    """Gemini CLI configuration."""

    executable: str | Path = "gemini"
    default_model: str = "gemini-2.5-flash"
    timeout: int = 120


@dataclass
class AppConfig:
    """Main application configuration."""

    app_name: str = "com.twardoch.geminpy"
    chrome: ChromeConfig = field(default_factory=ChromeConfig)
    gemini: GeminiConfig = field(default_factory=GeminiConfig)
    user_email: str | None = None
    verbose: bool = False

    @property
    def settings_dir(self) -> Path:
        """Get the settings directory path."""
        return Path(user_data_dir(appname=self.app_name))
</file>

<file path="src/geminpy/core/constants.py">
# this_file: src/geminpy/core/constants.py
"""Constants and enums for Geminpy."""

from enum import Enum


class AuthStatus(Enum):
    """OAuth authentication status."""

    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    SUCCESS = "success"
    FAILED = "failed"


class RateLimitIndicators:
    """Patterns indicating rate limit errors."""

    PATTERNS = ["429", "Quota exceeded", "rateLimitExceeded", "RESOURCE_EXHAUSTED"]


class BrowserID:
    """Browser identifiers."""

    TESTING = "testing"


# URLs and patterns
CDP_VERSION_URL = "http://localhost:{port}/json/version"
OAUTH_SIGNIN_PATTERN = r"accounts\.google\.com/signin/oauth"
SUCCESS_PATTERN = r"developers\.google\.com/gemini-code-assist/auth/auth_success_gemini"
</file>

<file path="src/geminpy/core/exceptions.py">
# this_file: src/geminpy/core/exceptions.py
"""Custom exceptions for Geminpy."""


class GeminiError(Exception):
    """Base exception for all Geminpy errors."""


class ChromeError(GeminiError):
    """Chrome-related errors."""


class BrowserManagementError(ChromeError):
    """Browser switching/management errors."""


class ChromeInstallationError(ChromeError):
    """Chrome for Testing installation errors."""


class AuthenticationError(GeminiError):
    """OAuth authentication errors."""


class RateLimitError(GeminiError):
    """API rate limit errors."""


class PlatformError(GeminiError):
    """Platform compatibility errors."""
</file>

<file path="src/geminpy/gemini/__init__.py">
# this_file: src/geminpy/gemini/__init__.py
"""Gemini CLI integration components."""

from .client import GeminiClient
from .executor import GeminiExecutor
from .parser import ResponseParser

__all__ = ["GeminiClient", "GeminiExecutor", "ResponseParser"]
</file>

<file path="src/geminpy/gemini/client.py">
# this_file: src/geminpy/gemini/client.py
"""Main orchestrator for Gemini CLI automation."""

import asyncio
import subprocess

from loguru import logger

from ..browser.automation import OAuthAutomator, UserResolver
from ..browser.chrome import ChromeManager, ChromeTestingManager
from ..browser.manager import BrowserManager
from ..core.config import AppConfig
from ..core.constants import BrowserID
from ..core.exceptions import RateLimitError
from .executor import GeminiExecutor
from .parser import ResponseParser


class GeminiClient:
    """Main orchestrator for Gemini CLI automation."""

    def __init__(self, config: AppConfig):
        """Initialize with app configuration."""
        self.config = config
        self.browser_manager = BrowserManager()
        self.chrome_testing_manager = ChromeTestingManager(config)
        self.chrome_manager = ChromeManager(config.chrome)
        self.oauth_automator = OAuthAutomator(config.chrome.debug_port)
        self.executor = GeminiExecutor(config.gemini.executable)
        self.parser = ResponseParser()

    async def execute_with_auth(
        self, args: list[str], user_email: str | None = None
    ) -> str | None:
        """Execute Gemini CLI with automatic OAuth handling."""
        # Resolve user email
        resolved_email = UserResolver.resolve_user_email(
            user_email, self.chrome_testing_manager.get_stored_user
        )

        # Save original browser
        orig_browser = self.browser_manager.get_current_default()
        logger.debug(f"Original default browser: {orig_browser}")

        # Ensure Chrome for Testing is available
        chrome_testing_path = self.chrome_testing_manager.ensure_available()
        logger.debug(f"Chrome for Testing path: {chrome_testing_path}")

        chrome_proc = None
        try:
            # Set Chrome for Testing as default browser
            if orig_browser != BrowserID.TESTING:
                logger.debug(f"Setting '{BrowserID.TESTING}' as default browser")
                self.browser_manager.set_default(BrowserID.TESTING)

            # Launch Chrome if needed
            if self.chrome_manager.is_cdp_ready():
                logger.debug("Chrome CDP already listening — using existing browser.")
            else:
                logger.debug("Launching Chrome for Testing with remote debugging…")
                chrome_proc = self.chrome_manager.launch(chrome_testing_path)

            # Wait for Chrome CDP to be ready
            await self.chrome_manager.wait_for_cdp()

            # Try running gemini with original args
            response = await self._try_gemini_with_oauth(args, resolved_email)

            if response is None:
                # Check if we should retry with flash model
                if "-m" not in args and "--model" not in args:
                    logger.debug(
                        "Rate limit detected, retrying with gemini-2.5-flash model..."
                    )
                    flash_args = ["-m", "gemini-2.5-flash"] + args
                    response = await self._try_gemini_with_oauth(
                        flash_args, resolved_email
                    )
                else:
                    logger.debug(
                        "Rate limit detected but model already specified, not retrying"
                    )

            # Store successful user for future use
            if response and resolved_email:
                self.chrome_testing_manager.set_stored_user(resolved_email)

            return response

        finally:
            # Restore browser
            if orig_browser != BrowserID.TESTING:
                self.browser_manager.set_default(orig_browser)
                logger.debug(f"Restored default browser to {orig_browser}")

            # Optionally quit Chrome
            if chrome_proc and chrome_proc.poll() is None and self.config.chrome.quit_chrome:
                logger.debug("Quitting Chrome for Testing as requested.")
                chrome_proc.terminate()
                await asyncio.sleep(1)

    async def _try_gemini_with_oauth(
        self, args: list[str], user_email: str | None
    ) -> str | None:
        """Try running gemini with OAuth automation."""
        # Start Gemini CLI process
        proc, _, _ = await self.executor.execute(args, self.config.gemini.timeout)

        # Run OAuth automation
        logger.debug("Starting OAuth automation flow...")
        try:
            await self.oauth_automator.run_oauth_flow(user_email)
            logger.debug("Automation flow finished.")
        except Exception as e:
            logger.debug(f"OAuth automation failed: {e}")
            proc.terminate()
            return None

        # Monitor for rate limits
        logger.debug("Waiting for gemini process to complete...")
        rate_limit_detected, stderr_lines = await self.executor.monitor_process(proc)

        if rate_limit_detected:
            logger.debug("Terminating gemini process due to rate limit detection")
            proc.terminate()
            return None

        # Wait for completion
        try:
            stdout, stderr = await self.executor.wait_completion(
                proc, self.config.gemini.timeout
            )

            if stderr:
                stderr_lines.append(stderr)

            # Final check for rate limits
            all_stderr = "".join(stderr_lines)
            if self.executor.check_rate_limit(all_stderr):
                logger.debug("Rate limit detected in final output")
                return None

            if proc.returncode == 0:
                logger.debug("Gemini process completed successfully.")

                # Parse stdout to extract clean model response
                if stdout:
                    clean_response = self.parser.extract_clean_response(stdout)
                    if clean_response:
                        logger.debug(f"Clean model response: {clean_response}")
                        return clean_response
                    else:
                        logger.debug("No clean model response found in output")
                        return None

            else:
                logger.debug(f"Gemini process failed with return code: {proc.returncode}")

            return None

        except subprocess.TimeoutExpired:
            logger.debug("Gemini process timed out")
            proc.terminate()
            return None
</file>

<file path="src/geminpy/gemini/executor.py">
# this_file: src/geminpy/gemini/executor.py
"""Manages Gemini CLI subprocess execution."""

import asyncio
import subprocess
from pathlib import Path

from loguru import logger

from ..core.constants import RateLimitIndicators


class GeminiExecutor:
    """Manages Gemini CLI subprocess execution."""

    def __init__(self, executable: str | Path = "gemini"):
        """Initialize with Gemini executable path."""
        self.executable = str(executable)

    async def execute(
        self, args: list[str], timeout: int = 120
    ) -> tuple[int, str, str]:
        """Execute gemini CLI and return (returncode, stdout, stderr)."""
        # Ensure -y flag is present
        if "-y" not in args and "--yes" not in args:
            args = ["-y"] + args

        cmd = [self.executable] + args
        logger.debug(f"Running gemini: {' '.join(cmd)}")

        # Create subprocess with real-time monitoring
        proc = subprocess.Popen(
            cmd,
            stderr=subprocess.PIPE,
            stdout=subprocess.PIPE,
            text=True,
            bufsize=1,
            universal_newlines=True,
        )

        # Give gemini a moment to open the URL
        await asyncio.sleep(2)

        return proc, None, None  # Return process for monitoring

    def check_rate_limit(self, text: str) -> bool:
        """Check if text contains rate limit indicators."""
        return any(pattern in text for pattern in RateLimitIndicators.PATTERNS)

    async def monitor_process(
        self, proc: subprocess.Popen, monitor_time: int = 15
    ) -> tuple[bool, list[str]]:
        """Monitor process for rate limits and collect stderr."""
        rate_limit_detected = False
        stderr_lines = []

        # Monitor process for up to monitor_time seconds
        start_time = asyncio.get_event_loop().time()
        while (
            proc.poll() is None
            and (asyncio.get_event_loop().time() - start_time) < monitor_time
        ):
            # Check if there's new stderr output
            if proc.stderr and proc.stderr.readable():
                try:
                    # Non-blocking read of available stderr data
                    import select

                    if select.select([proc.stderr], [], [], 0.1)[0]:
                        line = proc.stderr.readline()
                        if line:
                            stderr_lines.append(line)
                            logger.debug(f"Gemini stderr: {line.strip()}")

                            # Check for rate limit indicators
                            if self.check_rate_limit(line):
                                logger.debug("Rate limit detected in real-time output!")
                                rate_limit_detected = True
                                break
                except:
                    pass

            await asyncio.sleep(0.5)

        return rate_limit_detected, stderr_lines

    async def wait_completion(
        self, proc: subprocess.Popen, timeout: int = 90
    ) -> tuple[str, str]:
        """Wait for process completion and return stdout, stderr."""
        try:
            stdout, stderr = proc.communicate(timeout=timeout)
            logger.debug(f"Gemini process completed with return code: {proc.returncode}")
            return stdout or "", stderr or ""
        except subprocess.TimeoutExpired:
            logger.debug("Gemini process timed out - terminating...")
            proc.terminate()
            raise
</file>

<file path="src/geminpy/gemini/parser.py">
# this_file: src/geminpy/gemini/parser.py
"""Parses and cleans Gemini CLI output."""

from loguru import logger


class ResponseParser:
    """Parses and cleans Gemini CLI output."""

    AUTH_PATTERNS = [
        "Code Assist login required",
        "Attempting to open authentication page",
        "Otherwise navigate to:",
        "https://accounts.google.com/o/oauth2",
        "Waiting for authentication...",
        "Authentication successful",
        "[dotenv@",
    ]

    def extract_clean_response(self, stdout: str) -> str | None:
        """Extract clean model response from mixed output."""
        lines = stdout.strip().split("\n")

        # Skip authentication-related lines and find the actual response
        response_lines = []
        found_auth_complete = False

        for line in lines:
            line = line.strip()

            # Skip dotenv messages
            if line.startswith("[dotenv@"):
                continue

            # Skip authentication messages
            if any(auth_phrase in line for auth_phrase in self.AUTH_PATTERNS):
                continue

            # Skip empty lines at the start
            if not line and not response_lines:
                continue

            # If we find "Waiting for authentication...", the next non-empty line is likely the response
            if "Waiting for authentication..." in stdout:
                found_auth_complete = True

            # Collect non-authentication content
            if line:
                response_lines.append(line)

        # Return the cleaned response
        if response_lines:
            # If there's authentication flow, the response is typically the last meaningful content
            if found_auth_complete and response_lines:
                # Find the first line after authentication that looks like a response
                for i, line in enumerate(response_lines):
                    if not any(
                        skip_phrase in line
                        for skip_phrase in [
                            "dotenv",
                            "Code Assist",
                            "Attempting",
                            "navigate",
                            "oauth2",
                            "Waiting",
                        ]
                    ):
                        # Return from this line to the end
                        return "\n".join(response_lines[i:])

            # Fallback: return all non-auth lines
            return "\n".join(response_lines)

        return None
</file>

<file path="src/geminpy/utils/__init__.py">
# this_file: src/geminpy/utils/__init__.py
"""Utility components for Geminpy."""

from .logging import setup_logging
from .platform import check_dependencies, require_command, require_macos
from .storage import SettingsManager

__all__ = [
    "setup_logging",
    "check_dependencies",
    "require_command",
    "require_macos",
    "SettingsManager",
]
</file>

<file path="src/geminpy/utils/logging.py">
# this_file: src/geminpy/utils/logging.py
"""Centralized logging configuration using Loguru."""

import sys

from loguru import logger


def setup_logging(verbose: bool = False) -> None:
    """Configure loguru logging based on verbose flag."""
    logger.remove()  # Remove default handler
    if verbose:
        logger.add(
            sys.stderr,
            level="DEBUG",
            format="<level>{message}</level>",
            colorize=True,
        )
</file>

<file path="src/geminpy/utils/platform.py">
# this_file: src/geminpy/utils/platform.py
"""Platform utilities and dependency checks."""

import platform
import subprocess
from pathlib import Path

from geminpy.core.exceptions import PlatformError


def require_macos() -> None:
    """Ensure running on macOS."""
    if platform.system() != "Darwin":
        raise PlatformError("This package currently only supports macOS")


def require_command(command: str, install_hint: str) -> None:
    """Check if command exists, raise with install hint if not."""
    try:
        subprocess.run([command, "--version"], capture_output=True, check=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        raise PlatformError(f"Required command '{command}' not found. {install_hint}")


def check_dependencies() -> None:
    """Verify all required dependencies are available."""
    require_macos()
    require_command("macdefaultbrowser", "Install with: brew install macdefaultbrowser")
    require_command("npx", "Install Node.js from https://nodejs.org")
</file>

<file path="src/geminpy/utils/storage.py">
# this_file: src/geminpy/utils/storage.py
"""Settings storage management using platformdirs."""

import json
from pathlib import Path

from loguru import logger


class SettingsManager:
    """Manages persistent settings storage."""

    def __init__(self, settings_dir: Path):
        """Initialize settings manager with directory path."""
        self.settings_dir = settings_dir
        self.settings_file = settings_dir / "settings.json"

    def _load_settings(self) -> dict:
        """Load settings from disk."""
        if not self.settings_file.exists():
            return {}
        try:
            with open(self.settings_file, "r") as f:
                return json.load(f)
        except (json.JSONDecodeError, OSError) as e:
            logger.warning(f"Failed to load settings: {e}")
            return {}

    def _save_settings(self, settings: dict) -> None:
        """Save settings to disk."""
        self.settings_dir.mkdir(parents=True, exist_ok=True)
        with open(self.settings_file, "w") as f:
            json.dump(settings, f, indent=2)

    def get(self, key: str, default: str | None = None) -> str | None:
        """Get a setting value."""
        settings = self._load_settings()
        return settings.get(key, default)

    def set(self, key: str, value: str) -> None:
        """Set a setting value."""
        settings = self._load_settings()
        settings[key] = value
        self._save_settings(settings)

    def delete(self, key: str) -> None:
        """Delete a setting."""
        settings = self._load_settings()
        if key in settings:
            del settings[key]
            self._save_settings(settings)
</file>

<file path="src/geminpy/__init__.py">
# this_file: src/geminpy/__init__.py
"""Geminpy - Automated OAuth wrapper for Google's Gemini CLI."""

try:
    from .__version__ import __version__
except ImportError:
    __version__ = "0.0.0"  # Default version when not installed

from .api import ask, call_gemini_cli

__all__ = ["__version__", "ask", "call_gemini_cli"]
</file>

<file path="src/geminpy/__main__.py">
# this_file: src/geminpy/__main__.py
"""Entry point for python -m geminpy."""

import sys

from geminpy.cli import main

if __name__ == "__main__":
    sys.exit(main())
</file>

<file path="src/geminpy/api.py">
# this_file: src/geminpy/api.py
"""High-level API for Geminpy."""

import asyncio
from pathlib import Path

from .core.config import AppConfig
from .core.exceptions import GeminiError
from .gemini.client import GeminiClient
from .utils.logging import setup_logging
from .utils.platform import check_dependencies


async def call_gemini_cli(
    gemini_args: list[str],
    quit_chrome: bool = False,
    user: str | None = None,
    gemini_executable: str | Path = "gemini",
    verbose: bool = False,
) -> str | None:
    """Core function to call gemini CLI with OAuth automation.

    Args:
        gemini_args: Arguments to pass to the gemini CLI
        quit_chrome: Whether to quit Chrome after execution
        user: Optional specific user email to use for authentication
        gemini_executable: Path to the gemini executable
        verbose: Enable debug logging

    Returns:
        Clean response text from Gemini or None if failed

    Raises:
        GeminiError: If authentication or API call fails
    """
    # Setup logging
    setup_logging(verbose)

    # Check dependencies
    check_dependencies()

    # Create configuration
    config = AppConfig(
        verbose=verbose,
        user_email=user,
    )
    config.gemini.executable = gemini_executable
    config.chrome.quit_chrome = quit_chrome

    # Create and run client
    client = GeminiClient(config)
    return await client.execute_with_auth(gemini_args, user)


async def ask_async(
    prompt: str,
    user: str | None = None,
    verbose: bool = False,
) -> str:
    """Async version of ask.

    Args:
        prompt: The question/prompt to ask
        user: Optional specific user email to use for authentication
        verbose: Enable debug logging

    Returns:
        Clean text response from Gemini

    Raises:
        GeminiError: If authentication or API call fails
    """
    gemini_args = ["-p", prompt]
    response = await call_gemini_cli(
        gemini_args=gemini_args, user=user, verbose=verbose
    )

    if response is None:
        raise GeminiError("Failed to get response from Gemini")

    return response


def ask(
    prompt: str,
    user: str | None = None,
    verbose: bool = False,
) -> str:
    """Ask Gemini a question and get a clean response.

    Args:
        prompt: The question/prompt to ask
        user: Optional specific user email to use for authentication
        verbose: Enable debug logging

    Returns:
        Clean text response from Gemini

    Raises:
        GeminiError: If authentication or API call fails
    """
    return asyncio.run(ask_async(prompt, user, verbose))
</file>

<file path="src/geminpy/cli.py">
# this_file: src/geminpy/cli.py
"""CLI interface for Geminpy using Fire and Rich."""

import asyncio
from pathlib import Path

import fire
from rich.console import Console

from .api import call_gemini_cli

console = Console()


def cli(
    quit_chrome: bool = False,
    verbose: bool = False,
    user: str | None = None,
    gemini_executable: str | Path = "gemini",
    **gemini_args,
) -> None:
    """CLI interface for gemini with automated OAuth via Playwright.

    Args:
        quit_chrome: Quit Chrome after execution
        verbose: Enable verbose debug logging
        user: Specific user email to use for authentication
        gemini_executable: Path to the gemini executable
        **gemini_args: Arguments to pass to the gemini CLI
    """
    # Convert gemini_args dict to CLI argument list
    cli_args = []
    for key, value in gemini_args.items():
        # Use single dash for single char, double dash for multi-char
        flag = f"-{key}" if len(key) == 1 else f"--{key}"
        cli_args.append(flag)

        # Only add value if it's not a boolean True (flags don't need values)
        if value is not True:
            if value is False:
                # Skip false flags entirely
                cli_args.pop()  # Remove the flag we just added
            else:
                cli_args.append(str(value))

    # Run the command
    response = asyncio.run(
        call_gemini_cli(
            gemini_args=cli_args,
            quit_chrome=quit_chrome,
            user=user,
            gemini_executable=gemini_executable,
            verbose=verbose,
        )
    )

    # Print response if we got one (for CLI usage)
    if response:
        console.print(response)
    else:
        console.print("[red]Failed to get response from Gemini[/red]")


def main():
    """Main entry point for the CLI."""
    fire.Fire(cli)


if __name__ == "__main__":
    main()
</file>

<file path="tests/test_browser/test_automation.py">
# this_file: tests/test_browser/test_automation.py
"""Tests for the OAuthAutomator."""
</file>

<file path="tests/test_browser/test_chrome.py">
# this_file: tests/test_browser/test_chrome.py
"""Tests for the ChromeManager and ChromeTestingManager."""

from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest
import requests

from geminpy.browser.chrome import ChromeManager, ChromeTestingManager
from geminpy.core.config import AppConfig, ChromeConfig


@pytest.fixture
def app_config(tmp_path):
    """Pytest fixture for a mock AppConfig."""
    with patch("geminpy.core.config.user_data_dir", return_value=str(tmp_path)):
        yield AppConfig()


@pytest.fixture
def chrome_testing_manager(app_config):
    """Pytest fixture for a ChromeTestingManager instance."""
    return ChromeTestingManager(app_config)


@pytest.fixture
def chrome_manager():
    """Pytest fixture for a ChromeManager instance."""
    return ChromeManager(ChromeConfig())


def test_chrome_testing_manager_get_stored_path(chrome_testing_manager):
    """Verify that the manager can retrieve a stored path."""
    test_path = "/fake/chrome/path"
    chrome_testing_manager.settings.set("chrome_testing_path", test_path)
    assert chrome_testing_manager.get_stored_path() == Path(test_path)


@patch("pathlib.Path.exists", return_value=True)
def test_ensure_available_with_stored_path(mock_exists, chrome_testing_manager):
    """Verify that ensure_available returns a stored path if it exists."""
    test_path = "/fake/chrome/path"
    chrome_testing_manager.settings.set("chrome_testing_path", str(test_path))
    assert chrome_testing_manager.ensure_available() == Path(test_path)
    mock_exists.assert_called_once()


@patch("geminpy.browser.chrome.subprocess.run")
@patch("geminpy.browser.chrome.BrowserManager.get_available_browsers", return_value=[])
def test_ensure_available_installs_if_needed(
    mock_browsers, mock_run, chrome_testing_manager, tmp_path
):
    """Verify that ensure_available installs Chrome if it's not found."""
    install_path = tmp_path / "chrome"
    mock_run.return_value.stdout = f"chrome@stable {install_path}"

    # Mock the path's existence to avoid a FileNotFoundError in the test
    with patch.object(Path, "exists", return_value=True):
        result_path = chrome_testing_manager.install()

    assert result_path == install_path
    assert chrome_testing_manager.get_stored_path() == install_path


@patch("subprocess.Popen")
def test_chrome_manager_launch(mock_popen, chrome_manager, tmp_path):
    """Verify that ChromeManager launches Chrome with the correct arguments."""
    executable_path = tmp_path / "chrome"
    chrome_manager.launch(executable_path)
    mock_popen.assert_called_once()
    args, _ = mock_popen.call_args
    assert str(executable_path) in args[0]
    assert f"--remote-debugging-port={chrome_manager.config.debug_port}" in args[0]


@patch("requests.get")
def test_chrome_manager_is_cdp_ready(mock_get, chrome_manager):
    """Verify that is_cdp_ready correctly checks the CDP endpoint."""
    mock_get.return_value.status_code = 200
    assert chrome_manager.is_cdp_ready() is True

    mock_get.side_effect = requests.RequestException
    assert chrome_manager.is_cdp_ready() is False


@patch("requests.get")
@patch("asyncio.sleep", new_callable=MagicMock)
@pytest.mark.asyncio
async def test_chrome_manager_wait_for_cdp(mock_sleep, mock_get, chrome_manager):
    """Verify that wait_for_cdp waits for a successful connection."""
    mock_get.return_value.status_code = 200
    await chrome_manager.wait_for_cdp()
    mock_get.assert_called_once()
    mock_sleep.assert_not_called()
</file>

<file path="tests/test_browser/test_manager.py">
# this_file: tests/test_browser/test_manager.py
"""Tests for the BrowserManager."""

import subprocess
from unittest.mock import MagicMock, patch

from geminpy.browser.manager import BrowserManager


@patch("geminpy.browser.manager.require_command")
@patch("subprocess.run")
def test_get_current_default(mock_run, mock_require):
    """Verify that get_current_default correctly parses macdefaultbrowser output."""
    mock_process = MagicMock()
    mock_process.stdout = "safari\n* chrome\nfirefox\n"
    mock_run.return_value = mock_process

    default_browser = BrowserManager.get_current_default()
    assert default_browser == "chrome"
    mock_require.assert_called_once()


@patch("geminpy.browser.manager.require_command")
@patch("subprocess.run")
def test_get_available_browsers(mock_run, mock_require):
    """Verify that get_available_browsers correctly parses macdefaultbrowser output."""
    mock_process = MagicMock()
    mock_process.stdout = "safari\n* chrome\nfirefox\n"
    mock_run.return_value = mock_process

    browsers = BrowserManager.get_available_browsers()
    assert browsers == ["safari", "chrome", "firefox"]
    mock_require.assert_called_once()


@patch("geminpy.browser.manager.require_command")
@patch("subprocess.run")
def test_set_default(mock_run, mock_require):
    """Verify that set_default calls macdefaultbrowser with the correct arguments."""
    BrowserManager.set_default("firefox")
    mock_require.assert_called_once()
    mock_run.assert_called_once_with(["macdefaultbrowser", "firefox"], check=True)
</file>

<file path="tests/test_gemini/test_client.py">
# this_file: tests/test_gemini/test_client.py
"""Tests for the GeminiClient."""
</file>

<file path="tests/test_gemini/test_executor.py">
# this_file: tests/test_gemini/test_executor.py
"""Tests for the GeminiExecutor."""
</file>

<file path="tests/test_gemini/test_parser.py">
# this_file: tests/test_gemini/test_parser.py
"""Tests for the ResponseParser."""
</file>

<file path="tests/test_utils/test_platform.py">
# this_file: tests/test_utils/test_platform.py
"""Tests for the platform utilities."""

import subprocess
from unittest.mock import patch

import pytest

from geminpy.core.exceptions import PlatformError
from geminpy.utils.platform import (
    check_dependencies,
    require_command,
    require_macos,
)


def test_require_macos_on_mac():
    """Verify that require_macos does not raise on macOS."""
    with patch("platform.system", return_value="Darwin"):
        require_macos()  # Should not raise


def test_require_macos_on_other_os():
    """Verify that require_macos raises PlatformError on other OS."""
    with patch("platform.system", return_value="Linux"):
        with pytest.raises(PlatformError, match="currently only supports macOS"):
            require_macos()


def test_require_command_exists():
    """Verify that require_command does not raise if command exists."""
    with patch("subprocess.run") as mock_run:
        mock_run.return_value = subprocess.CompletedProcess(args=[], returncode=0)
        require_command("any_command", "install hint")  # Should not raise


def test_require_command_does_not_exist():
    """Verify that require_command raises PlatformError if command is missing."""
    with patch("subprocess.run", side_effect=FileNotFoundError):
        with pytest.raises(
            PlatformError, match="Required command 'any_command' not found"
        ):
            require_command("any_command", "install hint")


def test_check_dependencies_success():
    """Verify check_dependencies runs without error when all dependencies are met."""
    with patch("geminpy.utils.platform.require_macos") as mock_require_macos:
        with patch("geminpy.utils.platform.require_command") as mock_require_command:
            check_dependencies()
            assert mock_require_macos.called
            assert mock_require_command.call_count == 2


def test_check_dependencies_missing_command():
    """Verify check_dependencies raises PlatformError if a command is missing."""
    with patch("geminpy.utils.platform.require_macos"):
        with patch("geminpy.utils.platform.require_command", side_effect=PlatformError):
            with pytest.raises(PlatformError):
                check_dependencies()
</file>

<file path="tests/test_utils/test_storage.py">
# this_file: tests/test_utils/test_storage.py
"""Tests for the SettingsManager."""

from geminpy.utils.storage import SettingsManager


def test_settings_manager_set_get(tmp_path):
    """Verify that SettingsManager can set and get a setting."""
    settings_dir = tmp_path / "settings"
    manager = SettingsManager(settings_dir)

    # Test setting and getting a value
    manager.set("test_key", "test_value")
    assert manager.get("test_key") == "test_value"

    # Test that a non-existent key returns the default
    assert manager.get("non_existent_key") is None
    assert manager.get("non_existent_key", "default") == "default"

    # Test that the settings file was created
    settings_file = settings_dir / "settings.json"
    assert settings_file.exists()
    with open(settings_file) as f:
        content = f.read()
        assert '"test_key": "test_value"' in content
</file>

<file path="tests/conftest.py">
# this_file: tests/conftest.py
"""Pytest fixtures for the test suite."""
</file>

<file path="tests/test_api.py">
# this_file: tests/test_api.py
"""Tests for the high-level API."""

from geminpy.api import ask


def test_ask_importable():
    """Verify that the ask function can be imported."""
    assert callable(ask)
</file>

<file path="tests/test_cli.py">
# this_file: tests/test_cli.py
"""Tests for the CLI."""
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.1.0] - 2024-07-26

### Added
- Initial release of `geminpy`.
- Ported all functionality from the original `work/gemini_wrapper.py` script.
- Created a structured Python package with a modular architecture.
- **Core**: Configuration, custom exceptions, and constants.
- **Browser Management**:
    - `BrowserManager` for macOS default browser control.
    - `ChromeTestingManager` for automatic installation and management of Chrome for Testing.
    - `ChromeManager` for launching and managing Chrome processes with remote debugging.
- **OAuth Automation**: `OAuthAutomator` using Playwright to handle the Google OAuth flow seamlessly.
- **Gemini Integration**:
    - `GeminiExecutor` for robust `gemini` CLI subprocess execution and real-time monitoring.
    - `ResponseParser` to extract clean model responses from CLI output.
    - `GeminiClient` as the main orchestrator, combining all components.
- **User Experience**:
    - `UserResolver` to pick the correct Google account from CLI arguments, environment variables, or stored settings.
    - Automatic rate-limit detection and retry with the `gemini-2.5-flash` model.
- **API**:
    - `geminpy.api.call_gemini_cli` for advanced control.
    - `geminpy.api.ask` for simple question-answering.
- **CLI**:
    - Command-line interface via `fire` that acts as a drop-in replacement for the `gemini` CLI.
    - Entry points for `geminpy` and `python -m geminpy`.
- **Utilities**: Centralized logging, platform checks, and settings storage.
- Added basic project structure with `pyproject.toml` using Hatch.
</file>

<file path="TODO.md">
# TODO.md - Geminpy Porting & Refactoring Plan

## Overview

Port the monolithic `work/gemini_wrapper.py` script into a well-structured Python package `geminpy` with proper separation of concerns, comprehensive testing, and modern Python best practices.

## Phase 1: Architecture Design & Module Structure

### [x] 1.1 Create Final Package Structure

```
src/geminpy/
├── __init__.py              # Package exports & version
├── __version__.py           # Dynamic version (already exists)
├── __main__.py             # CLI entry point (python -m geminpy)
├── cli.py                   # CLI interface using Fire + Rich
├── core/
│   ├── __init__.py
│   ├── config.py           # Configuration management & dataclasses
│   ├── exceptions.py       # Custom exceptions
│   └── constants.py        # Constants & enums
├── browser/
│   ├── __init__.py
│   ├── manager.py          # BrowserManager class
│   ├── chrome.py           # ChromeManager & ChromeTestingManager
│   └── automation.py       # OAuthAutomator using Playwright
├── gemini/
│   ├── __init__.py
│   ├── client.py           # Main GeminiClient class
│   ├── executor.py         # GeminiExecutor for subprocess management
│   └── parser.py           # Response parser & cleaner
├── utils/
│   ├── __init__.py
│   ├── logging.py          # Loguru setup & utilities
│   ├── platform.py         # Platform checks & utilities
│   └── storage.py          # Settings storage management
└── api.py                   # High-level API (ask(), call_gemini_cli())
```

### [x] 1.2 Define Module Responsibilities

- **cli.py**: Fire-based CLI with Rich formatting, handles all CLI args
- **core/config.py**: Pydantic/dataclass models for configuration
- **core/exceptions.py**: GeminiError, ChromeError, AuthError, RateLimitError
- **browser/manager.py**: Abstract browser management, macOS default browser
- **browser/chrome.py**: Chrome for Testing installation & management
- **browser/automation.py**: Playwright-based OAuth automation
- **gemini/client.py**: Main orchestrator combining all components
- **gemini/executor.py**: Subprocess execution with real-time monitoring
- **gemini/parser.py**: Clean response extraction from CLI output
- **utils/logging.py**: Centralized Loguru configuration
- **utils/platform.py**: macOS checks, dependencies validation
- **utils/storage.py**: platformdirs-based settings management
- **api.py**: Simple API functions for programmatic use

## Phase 2: Core Infrastructure

### [x] 2.1 Set Up Base Configuration (core/config.py)

```python
# this_file: src/geminpy/core/config.py
from dataclasses import dataclass
from pathlib import Path
from typing import Optional
from platformdirs import user_data_dir

@dataclass
class ChromeConfig:
    """Chrome for Testing configuration."""
    executable_path: Optional[Path] = None
    debug_port: int = 9222
    user_data_dir: Path = Path("/tmp/chrome_gemini_automation")

@dataclass
class GeminiConfig:
    """Gemini CLI configuration."""
    executable: str | Path = "gemini"
    default_model: str = "gemini-2.5-flash"
    timeout: int = 120

@dataclass
class AppConfig:
    """Main application configuration."""
    app_name: str = "com.twardoch.geminpy"
    chrome: ChromeConfig = field(default_factory=ChromeConfig)
    gemini: GeminiConfig = field(default_factory=GeminiConfig)
    user_email: Optional[str] = None
    verbose: bool = False

    @property
    def settings_dir(self) -> Path:
        return Path(user_data_dir(appname=self.app_name))
```

### [x] 2.2 Implement Custom Exceptions (core/exceptions.py)

```python
# this_file: src/geminpy/core/exceptions.py
class GeminiError(Exception):
    """Base exception for all Geminpy errors."""

class ChromeError(GeminiError):
    """Chrome-related errors."""

class BrowserManagementError(ChromeError):
    """Browser switching/management errors."""

class ChromeInstallationError(ChromeError):
    """Chrome for Testing installation errors."""

class AuthenticationError(GeminiError):
    """OAuth authentication errors."""

class RateLimitError(GeminiError):
    """API rate limit errors."""

class PlatformError(GeminiError):
    """Platform compatibility errors."""
```

### [x] 2.3 Define Constants (core/constants.py)

```python
# this_file: src/geminpy/core/constants.py
from enum import Enum

class AuthStatus(Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    SUCCESS = "success"
    FAILED = "failed"

class RateLimitIndicators:
    PATTERNS = ["429", "Quota exceeded", "rateLimitExceeded", "RESOURCE_EXHAUSTED"]

class BrowserID:
    TESTING = "testing"

# URLs and patterns
CDP_VERSION_URL = "http://localhost:{port}/json/version"
OAUTH_SIGNIN_PATTERN = r"accounts\.google\.com/signin/oauth"
SUCCESS_PATTERN = r"developers\.google\.com/gemini-code-assist/auth/auth_success_gemini"
```

## Phase 3: Browser Management Module

### [x] 3.1 Implement Platform Utilities (utils/platform.py)

```python
# this_file: src/geminpy/utils/platform.py
import platform
import subprocess
from pathlib import Path

def require_macos() -> None:
    """Ensure running on macOS."""
    if platform.system() != "Darwin":
        raise PlatformError("This package currently only supports macOS")

def require_command(command: str, install_hint: str) -> None:
    """Check if command exists, raise with install hint if not."""
    try:
        subprocess.run([command, "--version"], capture_output=True, check=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        raise PlatformError(f"Required command '{command}' not found. {install_hint}")

def check_dependencies() -> None:
    """Verify all required dependencies are available."""
    require_macos()
    require_command("macdefaultbrowser", "Install with: brew install macdefaultbrowser")
    require_command("npx", "Install Node.js from https://nodejs.org")
```

### [x] 3.2 Create Browser Manager (browser/manager.py)

```python
# this_file: src/geminpy/browser/manager.py
import subprocess
from typing import List
from loguru import logger

class BrowserManager:
    """Manages default browser settings on macOS."""

    @staticmethod
    def get_current_default() -> str:
        """Get current default browser identifier."""
        result = subprocess.run(
            ["macdefaultbrowser"],
            capture_output=True,
            text=True,
            check=True
        )
        # Parse and return current default

    @staticmethod
    def get_available_browsers() -> List[str]:
        """List all available browser identifiers."""
        # Implementation

    @staticmethod
    def set_default(browser_id: str) -> None:
        """Set the default browser."""
        logger.debug(f"Setting default browser to: {browser_id}")
        subprocess.run(["macdefaultbrowser", browser_id], check=True)
```

### [x] 3.3 Implement Chrome Manager (browser/chrome.py)

- ChromeTestingManager for installation
- ChromeManager for process management
- CDP readiness checks
- Settings persistence

## Phase 4: Gemini Integration

### [x] 4.1 Create Gemini Executor (gemini/executor.py)

```python
# this_file: src/geminpy/gemini/executor.py
import asyncio
import subprocess
from typing import List, Optional, Tuple
from loguru import logger

class GeminiExecutor:
    """Manages Gemini CLI subprocess execution."""

    def __init__(self, executable: str | Path = "gemini"):
        self.executable = executable

    async def execute(
        self,
        args: List[str],
        timeout: int = 120
    ) -> Tuple[int, str, str]:
        """Execute gemini CLI and return (returncode, stdout, stderr)."""
        # Add -y flag if not present
        # Create subprocess with real-time monitoring
        # Detect rate limits in stderr
        # Return results
```

### [x] 4.2 Implement Response Parser (gemini/parser.py)

```python
# this_file: src/geminpy/gemini/parser.py
import re
from typing import Optional

class ResponseParser:
    """Parses and cleans Gemini CLI output."""

    AUTH_PATTERNS = [
        "Code Assist login required",
        "Attempting to open authentication page",
        "Otherwise navigate to:",
        "https://accounts.google.com/o/oauth2",
        "Waiting for authentication...",
        "Authentication successful",
        "[dotenv@"
    ]

    def extract_clean_response(self, stdout: str) -> Optional[str]:
        """Extract clean model response from mixed output."""
        # Skip auth-related lines
        # Find actual response content
        # Return cleaned text
```

### [x] 4.3 Build Main Client (gemini/client.py)

```python
# this_file: src/geminpy/gemini/client.py
from typing import Optional
from loguru import logger

class GeminiClient:
    """Main orchestrator for Gemini CLI automation."""

    def __init__(self, config: AppConfig):
        self.config = config
        self.browser_manager = BrowserManager()
        self.chrome_manager = ChromeManager(config.chrome)
        self.oauth_automator = OAuthAutomator()
        self.executor = GeminiExecutor(config.gemini.executable)
        self.parser = ResponseParser()

    async def execute_with_auth(
        self,
        args: List[str],
        user_email: Optional[str] = None
    ) -> Optional[str]:
        """Execute Gemini CLI with automatic OAuth handling."""
        # Save original browser
        # Set Chrome for Testing as default
        # Launch Chrome with CDP
        # Start Gemini CLI
        # Run OAuth automation
        # Parse response
        # Handle rate limits with retry
        # Restore browser
        # Return clean response
```

## Phase 5: OAuth Automation

### [x] 5.1 Port OAuth Automator (browser/automation.py)

- Connect to Chrome via CDP using Playwright
- Find OAuth page among tabs
- Click account (specific or first available)
- Click sign-in button
- Wait for success redirect
- Handle errors with screenshots

### [x] 5.2 Implement User Resolution

- Priority: CLI arg > env var > stored setting > first available
- Store successful user for future use

## Phase 6: High-Level API & CLI

### [x] 6.1 Create Simple API (api.py)

```python
# this_file: src/geminpy/api.py
from typing import Optional
import asyncio

async def ask_async(
    prompt: str,
    user: Optional[str] = None,
    verbose: bool = False
) -> str:
    """Async version of ask."""
    # Implementation

def ask(
    prompt: str,
    user: Optional[str] = None,
    verbose: bool = False
) -> str:
    """Ask Gemini a question and get a clean response."""
    return asyncio.run(ask_async(prompt, user, verbose))
```

### [x] 6.2 Implement CLI Interface (cli.py)

```python
# this_file: src/geminpy/cli.py
import fire
from rich.console import Console
from rich.progress import Progress

def main(**kwargs):
    """Main CLI entry point with Fire."""
    # Parse arguments
    # Show progress with Rich
    # Execute command
    # Display results
```

### [x] 6.3 Create Package Entry Points

- Update pyproject.toml with console_scripts
- Create **main**.py for `python -m geminpy`
- Ensure backward compatibility with gemini_wrapper.py args

## Phase 7: Testing Strategy

### [ ] 7.1 Unit Tests Structure

```
tests/
├── test_browser/
│   ├── test_manager.py
│   ├── test_chrome.py
│   └── test_automation.py
├── test_gemini/
│   ├── test_client.py
│   ├── test_executor.py
│   └── test_parser.py
├── test_utils/
│   ├── test_platform.py
│   └── test_storage.py
├── test_api.py
├── test_cli.py
└── conftest.py              # Pytest fixtures
```

### [ ] 7.2 Mock Strategy

- Mock subprocess calls for browser management
- Mock Playwright for OAuth automation
- Mock Gemini CLI execution
- Use pytest-asyncio for async tests

### [ ] 7.3 Integration Tests

- Test full flow with mock Gemini CLI
- Test rate limit detection and retry
- Test settings persistence
- Test error scenarios

## Phase 8: Documentation

### [ ] 8.1 Update Package Documentation

- Comprehensive docstrings for all modules
- Type hints for all functions
- Examples in docstrings

### [ ] 8.2 Create User Documentation

- Update README.md with new usage
- Migration guide from old script
- API reference with examples
- Troubleshooting guide

### [ ] 8.3 Generate Sphinx Docs

- Configure Sphinx with RTD theme
- Auto-generate API docs
- Add usage examples
- Deploy to Read the Docs

## Phase 9: Quality Assurance

### [ ] 9.1 Code Quality

- Run mypy with strict mode
- Achieve 100% type coverage
- Run ruff with all rules
- Format with comprehensive toolchain

### [ ] 9.2 Test Coverage

- Achieve >90% test coverage
- Cover all error paths
- Test async code thoroughly
- Benchmark performance

### [ ] 9.3 Security Review

- No credential storage
- Secure subprocess execution
- Validate all inputs
- Review OAuth flow security

## Phase 10: Migration & Deployment

### [ ] 10.1 Create Migration Script

```python
# migrate_settings.py
# Move settings from old location to new
# Update format if needed
# Preserve user preferences
```

### [ ] 10.2 Backward Compatibility

- DO NOT provide gemini_wrapper.py shim that uses new package, not needed

### [ ] 10.3 Package Release

- Set up GitHub Actions CI/CD
- Configure automatic versioning
- Create release workflow
- Publish to PyPI

## Implementation Priority

1. **Critical Path** (Do First):

   - [x] Phase 2: Core Infrastructure
   - [x] Phase 3: Browser Management
   - [x] Phase 4: Gemini Integration
   - [x] Phase 5: OAuth Automation

2. **Essential** (Do Second):

   - [x] Phase 6: API & CLI
   - [ ] Phase 7: Testing (at least basic tests)
   - [x] Phase 1: Final structure adjustments

3. **Polish** (Do Third):
   - [ ] Phase 8: Documentation
   - [ ] Phase 9: Quality Assurance
   - [ ] Phase 10: Migration & Deployment

## Success Criteria

- [x] All functionality from gemini_wrapper.py is preserved
- [x] Code is modular and testable
- [x] Comprehensive error handling
- [x] Full type hints with mypy passing
- [x] Rich CLI output with progress indicators
- [x] Async-first architecture
- [ ] > 90% test coverage
- [ ] Settings migration handled gracefully
- [ ] Documentation is comprehensive
- [ ] Package is pip-installable

## Notes

- Keep the original gemini_wrapper.py during development for reference
- Test on real macOS environment frequently
- Consider adding Windows/Linux support in future version
- Use feature flags for experimental features
- Consider adding caching for Chrome installation check
- Add telemetry opt-in for usage analytics (with user consent)

Remember: "Be creative, diligent, critical, relentless & funny!" 🚀
</file>

<file path=".github/workflows/push.yml">
name: Build & Test

on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"

      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"

  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}

      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"

      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/geminpy --cov=tests tests/

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml

  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5
</file>

<file path=".github/workflows/release.yml">
name: Release

on:
  push:
    tags: ["v*"]

permissions:
  contents: write
  id-token: write

jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/geminpy
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
</file>

<file path=".specstory/history/2025-06-27_23-09-analyze-gemini-wrapper-py-for-readme.md">
<!-- Generated by SpecStory -->

# Analyze gemini_wrapper.py for README (2025-06-28 01:09:44)

_**User**_

Analyze @gemini_wrapper.py and explain its purpose into @README.md 

---

_**Assistant**_



---

I'll analyze the `gemini_wrapper.py` file and update the README.md to explain its purpose and functionality.

---

Read file: work/gemini_wrapper.py

---



---

```diff
- 
- If I run:
- 
- ```
- npx -y @puppeteer/browsers install chrome@stable --platform mac --path /Applications --quiet
- ```
- 
- we get:
- 
- ```
- Downloading chrome stable - 170 MB [====================] 100% 0.0s 
- chrome@138.0.7204.49 /Applications/chrome/mac-138.0.7204.49/chrome-mac-x64/Google Chrome for Testing.app/Contents/MacOS/Google Chrome for Testing
- ```
- 
- or:
- 
- ```
- chrome@138.0.7204.49 /Applications/chrome/mac-138.0.7204.49/chrome-mac-x64/Google Chrome for Testing.app/Contents/MacOS/Google Chrome for Testing
- ```
- 
- we need to parse out the final path. 
- 
- And we’ll be using that browser. We need to be setting the `macdefaultbrowser testing`
+ # Gemini CLI OAuth Automation Wrapper
+ 
+ An automated OAuth wrapper for Google's `gemini` CLI tool on macOS that eliminates the need for manual authentication steps.
+ 
+ ## Overview
+ 
+ The `gemini_wrapper.py` script automates the complete Google OAuth flow for the `gemini` CLI by:
+ 
+ 1. **Installing Chrome for Testing** if not available (using `@puppeteer/browsers`)
+ 2. **Temporarily switching default browser** to Chrome for Testing (using `macdefaultbrowser`)
+ 3. **Launching Chrome** in remote debugging mode (port 9222)
+ 4. **Running the `gemini` CLI** with your specified arguments
+ 5. **Automating OAuth screens** via Playwright-over-CDP - selecting your account and clicking "Sign in"
+ 6. **Restoring original browser** and optionally quitting Chrome when done
+ 
+ ## Key Features
+ 
+ ### 🔐 **Seamless Authentication**
+ - Automatically handles Google OAuth flow without manual intervention
+ - Supports specific user account selection via multiple configuration methods
+ - Remembers your preferred account across sessions
+ 
+ ### 🌐 **Smart Browser Management**
+ - Uses Chrome for Testing to avoid conflicts with your regular browser
+ - Automatically installs Chrome for Testing if needed
+ - Temporarily switches default browser for OAuth, then restores it
+ 
+ ### 🔄 **Rate Limit Handling**
+ - Detects API rate limits in real-time
+ - Automatically retries with `gemini-2.5-flash` model when rate limited
+ - Graceful failure handling with informative error messages
+ 
+ ### 📊 **Clean Response Extraction**
+ - Filters out authentication noise from gemini CLI output
+ - Returns clean model responses for programmatic use
+ - Preserves original CLI behavior for interactive use
+ 
+ ## Installation & Requirements
+ 
+ ### Prerequisites
+ 
+ **macOS only** - This tool requires macOS (Darwin) due to browser management dependencies.
+ 
+ #### Install required tools:
+ ```bash
+ # Install macdefaultbrowser utility
+ brew install macdefaultbrowser
+ 
+ # Install Playwright browsers (one-time setup)
+ playwright install chromium
+ ```
+ 
+ #### Dependencies (auto-installed via uv):
+ - `fire>=0.5.0` - CLI interface
+ - `playwright>=1.43.0` - Browser automation
+ - `requests>=2.31.0` - HTTP requests
+ - `platformdirs>=4.0.0` - Cross-platform directories
+ - `loguru>=0.7.0` - Logging
+ 
+ ## Usage
+ 
+ ### 1. CLI Interface (Direct Replacement)
+ 
+ Use exactly like the regular `gemini` CLI, but with automatic OAuth:
+ 
+ ```bash
+ # Ask a question
+ ./gemini_wrapper.py -p "Explain Python decorators"
+ 
+ # Use specific model
+ ./gemini_wrapper.py -m "gemini-pro" -p "Write a Python function"
+ 
+ # With verbose logging
+ ./gemini_wrapper.py --verbose -p "Hello world"
+ 
+ # Quit Chrome when done
+ ./gemini_wrapper.py --quit-chrome -p "What's the weather?"
+ ```
+ 
+ ### 2. Programmatic Interface
+ 
+ ```python
+ from gemini_wrapper import ask
+ 
+ # Simple question-answer
+ response = ask("Explain quantum computing in simple terms")
+ print(response)
+ 
+ # With specific user account
+ response = ask("Generate Python code", user="myemail@gmail.com")
+ print(response)
+ 
+ # With debug logging
+ response = ask("Help with debugging", verbose=True)
+ print(response)
+ ```
+ 
+ ### 3. Advanced Usage
+ 
+ ```python
+ import asyncio
+ from gemini_wrapper import call_gemini_cli
+ 
+ # Full control over gemini arguments
+ response = await call_gemini_cli(
+     gemini_args=["-m", "gemini-pro", "-p", "Your prompt here"],
+     user="specific@email.com",
+     verbose=True,
+     quit_chrome=True
+ )
+ ```
+ 
+ ## User Account Configuration
+ 
+ The wrapper resolves your Google account in this priority order:
+ 
+ 1. **`--user` CLI argument**: `./gemini_wrapper.py --user="you@gmail.com" -p "Hello"`
+ 2. **`GEMINI_CLI_USER` environment variable**: `export GEMINI_CLI_USER="you@gmail.com"`
+ 3. **Stored in settings.json**: Automatically saved from previous successful authentications
+ 4. **First available account**: If none specified, uses the first Google account found
+ 
+ ## How It Works
+ 
+ ### Browser Automation Flow
+ 
+ 1. **Setup Phase**:
+    - Checks if Chrome for Testing is installed, installs if needed
+    - Saves current default browser
+    - Sets Chrome for Testing as temporary default
+ 
+ 2. **Authentication Phase**:
+    - Launches Chrome in debugging mode (port 9222)
+    - Starts `gemini` CLI which opens OAuth URL in Chrome
+    - Playwright connects to Chrome via Chrome DevTools Protocol (CDP)
+    - Automatically clicks your account and "Sign in" button
+ 
+ 3. **Execution Phase**:
+    - Waits for OAuth success redirect
+    - Monitors gemini process for completion or rate limits
+    - Extracts clean response from mixed CLI output
+ 
+ 4. **Cleanup Phase**:
+    - Restores original default browser
+    - Optionally quits Chrome for Testing
+    - Returns clean response text
+ 
+ ### Rate Limit Handling
+ 
+ When the original request hits rate limits:
+ ```
+ gemini-wrapper detects: "429" or "Quota exceeded" or "rateLimitExceeded"
+ ↓
+ Automatically retries with: gemini -m "gemini-2.5-flash" [your-args]
+ ↓
+ Returns response or fails gracefully
+ ```
+ 
+ ## File Structure
+ 
+ ```
+ work/
+ ├── gemini_wrapper.py          # Main automation script
+ └── settings.json              # Auto-generated settings (Chrome path, user email)
+ ```
+ 
+ ## Settings Storage
+ 
+ Settings are automatically stored in:
+ - **Path**: `~/Library/Application Support/com.twardoch.chrometesting/settings.json`
+ - **Contents**: Chrome for Testing executable path, preferred user email
+ - **Auto-managed**: No manual editing required
+ 
+ ## Troubleshooting
+ 
+ ### Common Issues
+ 
+ **"Chrome CDP did not become available"**
+ - Another Chrome instance may be running without `--remote-debugging-port`
+ - Check if port 9222 is blocked: `curl http://localhost:9222/json/version`
+ - Look at debug logs: `/tmp/gemini_chrome_stderr.log`
+ 
+ **"macdefaultbrowser utility missing"**
+ ```bash
+ brew install macdefaultbrowser
+ ```
+ 
+ **Authentication fails**
+ - Enable verbose mode: `--verbose` to see detailed OAuth flow
+ - Check screenshots saved to: `oauth_error*.png`
+ - Verify your Google account has access to Gemini
+ 
+ **Rate limits persist**
+ - The wrapper automatically tries `gemini-2.5-flash` on rate limits
+ - Wait a few minutes before retrying
+ - Check your Gemini API quota in Google Cloud Console
+ 
+ ### Debug Mode
+ 
+ Enable verbose logging to see the full automation process:
+ 
+ ```bash
+ ./gemini_wrapper.py --verbose -p "Your question"
+ ```
+ 
+ This shows:
+ - Chrome installation and launch details
+ - Browser switching operations  
+ - OAuth flow step-by-step
+ - Gemini CLI output parsing
+ - Error details and screenshots
+ 
+ ## Security Notes
+ 
+ - **Browser isolation**: Uses Chrome for Testing, separate from your regular Chrome
+ - **Temporary access**: Only switches default browser during authentication
+ - **Local automation**: All OAuth automation happens locally via CDP
+ - **No credential storage**: No passwords or tokens are stored, only email preference
+ 
+ The wrapper provides a seamless, secure way to use Google's Gemini CLI without manual OAuth interruptions.
  
  
```

---



---

I've successfully analyzed the `gemini_wrapper.py` file and completely rewritten the README.md to provide a comprehensive explanation of this OAuth automation tool.

## What `gemini_wrapper.py` Does

The script is a **sophisticated OAuth automation wrapper** for Google's `gemini` CLI on macOS that:

### 🎯 **Main Purpose**
Eliminates manual OAuth authentication steps when using Google's Gemini CLI by automating the entire browser-based authentication flow.

### 🔧 **Key Components**
- **ChromeTestingManager**: Installs and manages Chrome for Testing
- **BrowserManager**: Handles default browser switching via `macdefaultbrowser` 
- **ChromeManager**: Manages Chrome processes and CDP connections
- **OAuthAutomator**: Automates the actual OAuth flow using Playwright
- **UserResolver**: Resolves user email from multiple sources (CLI, env var, settings)

### 🌊 **Automation Flow**
1. Installs Chrome for Testing if needed (via `@puppeteer/browsers`)
2. Temporarily switches default browser to Chrome for Testing
3. Launches Chrome in remote debugging mode (port 9222)
4. Runs the `gemini` CLI which opens OAuth URL
5. Uses Playwright-over-CDP to automatically click your account and "Sign in"
6. Monitors for rate limits and retries with `gemini-2.5-flash` if needed
7. Extracts clean responses from CLI output
8. Restores original default browser

### 💡 **Smart Features**
- **Rate limit detection** with automatic fallback to faster models
- **Multi-source user configuration** (CLI arg, env var, stored settings)
- **Clean response extraction** filtering out authentication noise
- **Browser isolation** using Chrome for Testing to avoid conflicts
- **Comprehensive error handling** with debug screenshots

The tool provides both a **CLI interface** (drop-in replacement for `gemini`) and a **programmatic API** (`ask()` function) for seamless integration into workflows.

This is particularly useful for developers who frequently use Google's Gemini CLI and want to avoid the manual OAuth interruptions that normally occur.

---
</file>

<file path=".specstory/.gitignore">
# SpecStory explanation file
/.what-is-this.md
</file>

<file path="src/geminpy/geminpy.py">
#!/usr/bin/env python3
"""geminpy: 

Created by Adam Twardoch
"""

from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional, Union
import logging

__version__ = "0.1.0"

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


@dataclass
class Config:
    """Configuration settings for geminpy."""
    name: str
    value: Union[str, int, float]
    options: Optional[Dict[str, Any]] = None


def process_data(
    data: List[Any],
    config: Optional[Config] = None,
    *,
    debug: bool = False
) -> Dict[str, Any]:
    """Process the input data according to configuration.
    
    Args:
        data: Input data to process
        config: Optional configuration settings
        debug: Enable debug mode
        
    Returns:
        Processed data as a dictionary
        
    Raises:
        ValueError: If input data is invalid
    """
    if debug:
        logger.setLevel(logging.DEBUG)
        logger.debug("Debug mode enabled")
        
    if not data:
        raise ValueError("Input data cannot be empty")
        
    # TODO: Implement data processing logic
    result: Dict[str, Any] = {}
    return result


def main() -> None:
    """Main entry point for geminpy."""
    try:
        # Example usage
        config = Config(
            name="default",
            value="test",
            options={"key": "value"}
        )
        result = process_data([], config=config)
        logger.info("Processing completed: %s", result)
        
    except Exception as e:
        logger.error("An error occurred: %s", str(e))
        raise


if __name__ == "__main__":
    main()
</file>

<file path="tests/test_package.py">
"""Test suite for geminpy."""

def test_version():
    """Verify package exposes version."""
    import geminpy
    assert geminpy.__version__
</file>

<file path="work/gemini_wrapper.py">
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = [
#   "fire>=0.5.0",
#   "playwright>=1.43.0",
#   "requests>=2.31.0",
#   "platformdirs>=4.0.0",
#   "loguru>=0.7.0",
# ]
# ///
# this_file: geminiclu/gemini_wrapper.py
"""gemini_wrapper.py

Automates Google OAuth flow for the `gemini` CLI on macOS by:
1. Installing Chrome for Testing if not available (using @puppeteer/browsers).
2. Temporarily setting Chrome for Testing as the default browser
   (using *macdefaultbrowser testing*).
3. Launching Chrome for Testing in remote-debugging mode (port 9222).
4. Running the `gemini` CLI with given arguments.
5. Connecting to the running Chrome via Playwright-over-CDP and completing the
   OAuth screens automatically — picking either the account specified in
   ``$GEMINI_CLI_USER`` or the first available account, then pressing
   *Sign in*.
6. Restoring the original default browser and optionally quitting Chrome.

Notes
-----
* Playwright browsers must be installed once: ``playwright install chromium``.
* Chrome for Testing is downloaded automatically via @puppeteer/browsers.
"""

from __future__ import annotations

import asyncio
import json
import os
import platform
import re
import subprocess
import sys
import time
from pathlib import Path
from typing import Optional

import fire  # type: ignore
import platformdirs  # type: ignore
import requests  # type: ignore
from loguru import logger  # type: ignore
from playwright.async_api import Playwright, Page, async_playwright  # type: ignore

# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

DEBUG_PORT = 9222
CDP_VERSION_URL = f"http://localhost:{DEBUG_PORT}/json/version"
TESTING_BROWSER_ID = "testing"

OAUTH_SIGNIN_RE = re.compile(r"accounts\.google\.com/signin/oauth")
SUCCESS_RE = re.compile(
    r"developers\.google\.com/gemini-code-assist/auth/auth_success_gemini"
)

# Settings storage
SETTINGS_DIR = Path(platformdirs.user_data_dir(appname="com.twardoch.chrometesting"))
SETTINGS_FILE = SETTINGS_DIR / "settings.json"


# ---------------------------------------------------------------------------
# Chrome for Testing Management
# ---------------------------------------------------------------------------


def log(message: str) -> None:
    logger.debug(message)


class ChromeTestingManager:
    """Manages Chrome for Testing installation and configuration."""

    @staticmethod
    def _load_settings() -> dict:
        """Load Chrome for Testing settings from disk."""
        if not SETTINGS_FILE.exists():
            return {}
        try:
            with open(SETTINGS_FILE, "r") as f:
                return json.load(f)
        except (json.JSONDecodeError, OSError):
            return {}

    @staticmethod
    def _save_settings(settings: dict) -> None:
        """Save Chrome for Testing settings to disk."""
        SETTINGS_DIR.mkdir(parents=True, exist_ok=True)
        with open(SETTINGS_FILE, "w") as f:
            json.dump(settings, f, indent=2)

    @classmethod
    def get_stored_path(cls) -> Optional[str]:
        """Get the stored Chrome for Testing executable path."""
        settings = cls._load_settings()
        return settings.get("chrome_testing_path")

    @classmethod
    def set_stored_path(cls, path: str) -> None:
        """Store the Chrome for Testing executable path."""
        settings = cls._load_settings()
        settings["chrome_testing_path"] = path
        cls._save_settings(settings)

    @classmethod
    def get_stored_user(cls) -> Optional[str]:
        """Get the stored gemini CLI user email."""
        settings = cls._load_settings()
        return settings.get("gemini_cli_user")

    @classmethod
    def set_stored_user(cls, user_email: str) -> None:
        """Store the gemini CLI user email."""
        settings = cls._load_settings()
        settings["gemini_cli_user"] = user_email
        cls._save_settings(settings)

    @classmethod
    def install(cls) -> str:
        """Install Chrome for Testing and return the executable path."""
        log("Installing Chrome for Testing...")

        cmd = [
            "npx",
            "-y",
            "@puppeteer/browsers",
            "install",
            "chrome@stable",
            "--platform",
            "mac",
            "--path",
            "/Applications",
            "--quiet",
        ]

        log(f"Running: {' '.join(cmd)}")
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)

        # Parse the output to find the executable path
        executable_path = None
        for line in result.stdout.strip().split("\n"):
            line = line.strip()
            if line and not line.startswith("Downloading"):
                parts = line.split(" ", 1)
                if len(parts) == 2:
                    executable_path = parts[1]
                    break

        if not executable_path:
            raise RuntimeError(
                f"Could not parse Chrome for Testing path from output: {result.stdout}"
            )

        if not Path(executable_path).exists():
            raise RuntimeError(
                f"Chrome for Testing executable not found at: {executable_path}"
            )

        log(f"Chrome for Testing installed at: {executable_path}")
        cls.set_stored_path(executable_path)
        return executable_path

    @classmethod
    def ensure_available(cls) -> str:
        """Ensure Chrome for Testing is available and return the executable path."""
        # Check if we already have the path stored
        stored_path = cls.get_stored_path()
        if stored_path and Path(stored_path).exists():
            log(f"Using existing Chrome for Testing: {stored_path}")
            return stored_path

        # Check if 'testing' browser is available in macdefaultbrowser
        available_browsers = BrowserManager.get_available_browsers()
        if TESTING_BROWSER_ID not in available_browsers:
            log(
                f"'{TESTING_BROWSER_ID}' browser not found in available browsers: {available_browsers}"
            )
            log("Installing Chrome for Testing...")
            return cls.install()
        else:
            log(f"'{TESTING_BROWSER_ID}' browser found in available browsers")
            stored_path = cls.get_stored_path()
            if stored_path and Path(stored_path).exists():
                return stored_path
            else:
                log("Chrome for Testing path not found, reinstalling...")
                return cls.install()


# ---------------------------------------------------------------------------
# Browser Management
# ---------------------------------------------------------------------------


class BrowserManager:
    """Manages default browser settings."""

    @staticmethod
    def _require_mac() -> None:
        if platform.system() != "Darwin":
            raise RuntimeError("This helper only supports macOS (Darwin)")

    @staticmethod
    def _require_defaultbrowser() -> None:
        try:
            subprocess.run(["macdefaultbrowser"], capture_output=True, check=True)
        except (subprocess.CalledProcessError, FileNotFoundError):
            raise RuntimeError(
                "`macdefaultbrowser` utility missing — brew install macdefaultbrowser"
            )

    @classmethod
    def get_current_default(cls) -> str:
        """Return the current default browser identifier."""
        cls._require_defaultbrowser()
        result = subprocess.run(
            ["macdefaultbrowser"], capture_output=True, text=True, check=True
        )
        for line in result.stdout.splitlines():
            line = line.strip()
            if line and line.startswith("* "):
                return line[2:]
        return (
            result.stdout.splitlines()[0].strip() if result.stdout.splitlines() else ""
        )

    @classmethod
    def get_available_browsers(cls) -> list[str]:
        """Return list of available browser identifiers."""
        cls._require_defaultbrowser()
        result = subprocess.run(
            ["macdefaultbrowser"], capture_output=True, text=True, check=True
        )
        browsers = []
        for line in result.stdout.splitlines():
            line = line.strip()
            if line:
                browsers.append(line[2:] if line.startswith("* ") else line)
        return browsers

    @classmethod
    def set_default(cls, browser_id: str) -> None:
        """Set the default browser."""
        cls._require_defaultbrowser()
        subprocess.run(["macdefaultbrowser", browser_id], check=True)


# ---------------------------------------------------------------------------
# Chrome Process Management
# ---------------------------------------------------------------------------


class ChromeManager:
    """Manages Chrome for Testing processes."""

    @staticmethod
    def launch(executable_path: str) -> subprocess.Popen:
        """Launch Chrome for Testing with CDP enabled."""
        user_data_dir = "/tmp/chrome_gemini_automation"
        args = [
            executable_path,
            f"--remote-debugging-port={DEBUG_PORT}",
            f"--user-data-dir={user_data_dir}",
            "--no-first-run",
            "--no-default-browser-check",
            "--disable-popup-blocking",
            "--disable-web-security",
            "--disable-features=VizDisplayCompositor",
            "about:blank",
        ]

        log(f"exec: {' '.join(args)}")

        # Capture stderr for debugging
        stderr_file = "/tmp/gemini_chrome_stderr.log"
        with open(stderr_file, "w") as f:
            f.write(f"Chrome for Testing launch command: {' '.join(args)}\n")
            f.write("=" * 50 + "\n")

        log(f"Chrome stderr will be logged to: {stderr_file}")

        return subprocess.Popen(
            args, stdout=subprocess.DEVNULL, stderr=open(stderr_file, "a")
        )

    @staticmethod
    def is_cdp_ready(port: int = DEBUG_PORT) -> bool:
        """Check if Chrome CDP endpoint is ready."""
        try:
            response = requests.get(f"http://localhost:{port}/json/version", timeout=1)
            return response.status_code == 200
        except requests.RequestException:
            return False

    @classmethod
    async def wait_for_cdp(cls, timeout: int = 20) -> None:
        """Wait for Chrome's CDP to be ready."""
        log("Waiting for Chrome CDP port to open...")
        start_time = time.time()
        retry_count = 0
        max_retries = 20

        while time.time() - start_time < timeout:
            retry_count += 1
            try:
                response = requests.get(CDP_VERSION_URL, timeout=1)
                if response.status_code == 200:
                    log(f"Chrome CDP is ready after {retry_count} attempts.")
                    return
                else:
                    log(
                        f"retry {retry_count}/{max_retries} … HTTP {response.status_code}"
                    )
            except requests.ConnectionError:
                log(f"retry {retry_count}/{max_retries} … connection refused")
            except requests.RequestException as e:
                log(f"retry {retry_count}/{max_retries} … {type(e).__name__}: {e}")

            await asyncio.sleep(1)

        error_msg = f"""
ERROR: Chrome never opened port {DEBUG_PORT} after {retry_count} attempts.

Possible causes:
• Another Chrome instance was already running without --remote-debugging-port
• A firewall is blocking localhost:{DEBUG_PORT}
• Chrome failed to start (check /tmp/gemini_chrome_stderr.log)

Try manually:
  curl http://localhost:{DEBUG_PORT}/json/version

You should get a JSON response with 'webSocketDebuggerUrl'.
"""
        logger.error(error_msg.strip())
        raise RuntimeError(
            f"Chrome CDP did not become available after {retry_count} attempts."
        )


# ---------------------------------------------------------------------------
# User Resolution
# ---------------------------------------------------------------------------


class UserResolver:
    """Resolves the target user email from multiple sources."""

    @staticmethod
    def resolve_user_email(cli_user: Optional[str] = None) -> Optional[str]:
        """Resolve user email from multiple sources in priority order."""
        # 1. --user command line argument
        if cli_user:
            log(f"Using user from CLI argument: {cli_user}")
            return cli_user

        # 2. GEMINI_CLI_USER environment variable
        env_user = os.environ.get("GEMINI_CLI_USER")
        if env_user:
            log(f"Using user from GEMINI_CLI_USER env var: {env_user}")
            return env_user

        # 3. gemini_cli_user in settings.json
        stored_user = ChromeTestingManager.get_stored_user()
        if stored_user:
            log(f"Using user from settings.json: {stored_user}")
            return stored_user

        # 4. No specific user - will use first available account
        log("No specific user configured - will use first available account")
        return None


# ---------------------------------------------------------------------------
# OAuth Automation
# ---------------------------------------------------------------------------


class OAuthAutomator:
    """Handles OAuth flow automation using Playwright."""

    @staticmethod
    async def _connect_playwright() -> tuple[Playwright, Page]:
        """Connect to Chrome via CDP and return playwright instance and OAuth page."""
        log("Connecting to Chrome over CDP...")
        info = requests.get(CDP_VERSION_URL, timeout=10).json()
        ws_url = info["webSocketDebuggerUrl"]
        pw = await async_playwright().start()
        browser = await pw.chromium.connect_over_cdp(ws_url)

        if not browser.contexts:
            raise RuntimeError(
                "No browser contexts found. Is Chrome running correctly?"
            )
        context = browser.contexts[0]

        # Find the OAuth page
        log("Searching for Google OAuth page among open tabs...")
        for _ in range(8):  # Reduced from 15 to 8 seconds
            for page in context.pages:
                try:
                    url = page.url
                    if "accounts.google.com" in url:
                        log(f"Found potential OAuth page: {url}")
                        await page.bring_to_front()
                        return pw, page
                except Exception as e:
                    log(f"Could not check a page, it might be closed: {e}")
            log("OAuth page not found yet, retrying...")
            await asyncio.sleep(1)

        raise RuntimeError("Could not find a Google Accounts page to automate.")

    @staticmethod
    async def _wait_for_url(
        page: Page, pattern: re.Pattern, timeout: int = 120
    ) -> None:
        """Wait for page URL to match pattern."""
        await page.wait_for_url(pattern, wait_until="load", timeout=timeout * 1000)

    @classmethod
    async def run_oauth_flow(cls, user_email: Optional[str]) -> None:
        """Execute the complete OAuth flow."""
        pw, page = await cls._connect_playwright()
        try:
            log(f"Automating page: {page.url}")

            # Wait for page to be ready
            await page.wait_for_load_state(
                "domcontentloaded", timeout=15000
            )  # Reduced from 20s
            await asyncio.sleep(1)  # Reduced from 2 seconds

            # Step 1: Click the account
            if user_email:
                log(f"Looking for specific account: {user_email}")
                # Try direct data-identifier selection first
                account_locator = page.locator(f'[data-identifier="{user_email}"]')

                if await account_locator.count() == 0:
                    log(
                        f"Specific account '{user_email}' not found by data-identifier, trying by text content"
                    )
                    # Fallback to searching by text content in links
                    account_locator = page.get_by_role(
                        "link", name=re.compile(user_email, re.IGNORECASE)
                    )

                    if await account_locator.count() == 0:
                        log(
                            f"Specific account '{user_email}' not found, using first available account"
                        )
                        # Use first element with data-identifier
                        account_locator = page.locator("[data-identifier]").first
            else:
                log("Looking for first available account")
                # Use first element with data-identifier
                account_locator = page.locator("[data-identifier]").first

            account_count = await account_locator.count()
            if account_count == 0:
                await page.screenshot(path="oauth_error_no_account.png")
                target_desc = f"'{user_email}'" if user_email else "any account"
                raise RuntimeError(
                    f"Could not find {target_desc} using direct selection."
                )

            log(f"Account found ({account_count} matches), clicking it...")
            await account_locator.click()

            # Step 2: Click the sign-in button
            log("Waiting for the approval page to load...")
            await page.wait_for_load_state(
                "domcontentloaded", timeout=10000
            )  # Reduced from 15s
            await asyncio.sleep(1)  # Reduced from 2 seconds

            log("Looking for sign-in button...")
            sign_in_locator = page.get_by_role(
                "button", name=re.compile("Sign in|Continue", re.IGNORECASE)
            )

            if await sign_in_locator.count() == 0:
                await page.screenshot(path="oauth_error_no_signin.png")
                raise RuntimeError(
                    "Could not find 'Sign in' or 'Continue' button using get_by_role."
                )

            log("Sign-in button found, clicking it...")
            await sign_in_locator.first.click()

            # Step 3: Wait for success and close tab
            log("Waiting for success redirect...")
            await cls._wait_for_url(page, SUCCESS_RE, timeout=60)
            log("OAuth flow completed successfully ✔")
            log(f"Success page reached: {page.url}")

            log("Closing success tab...")
            await page.close()
            log("Success tab closed successfully")

        except Exception as e:
            logger.error(f"An error occurred during OAuth automation: {e}")
            await page.screenshot(path="oauth_error.png")
            log("Saved a screenshot to oauth_error.png for debugging.")
            raise
        finally:
            log("Stopping Playwright.")
            await pw.stop()


# ---------------------------------------------------------------------------
# Main Application
# ---------------------------------------------------------------------------


class GeminiWrapper:
    """Main application class for Gemini OAuth automation."""

    def __init__(self, verbose: bool = False):
        self.verbose = verbose
        self._setup_logging()
        BrowserManager._require_mac()

    def _setup_logging(self) -> None:
        """Configure loguru logging based on verbose flag."""
        logger.remove()  # Remove default handler
        if self.verbose:
            logger.add(
                sys.stderr,
                level="DEBUG",
                format="<level>{message}</level>",
                colorize=True,
            )

    async def _try_gemini_with_oauth_and_return_response(
        self,
        gemini_args: list[str],
        gemini_executable: str | Path,
        user_email: Optional[str],
    ) -> Optional[str]:
        """Try running gemini with OAuth automation. Returns clean response text or None if failed."""
        # Launch Gemini CLI tool
        gemini_cmd = [str(gemini_executable), *gemini_args]
        log(f"Running gemini: {' '.join(gemini_cmd)}")

        # Capture stderr to detect rate limits in real-time
        gemini_proc = subprocess.Popen(
            gemini_cmd,
            stderr=subprocess.PIPE,
            stdout=subprocess.PIPE,
            text=True,
            bufsize=1,  # Line buffered
            universal_newlines=True,
        )

        # Give gemini a moment to open the URL
        await asyncio.sleep(2)  # Reduced from 5 seconds

        # Run OAuth automation
        log("Starting OAuth automation flow...")
        try:
            await OAuthAutomator.run_oauth_flow(user_email)
            log("Automation flow finished.")
        except Exception as e:
            log(f"OAuth automation failed: {e}")
            gemini_proc.terminate()
            return None

        # Monitor stderr output in real-time for rate limits
        log("Waiting for gemini process to complete...")
        log(f"Gemini process status: running={gemini_proc.poll() is None}")

        rate_limit_detected = False
        stderr_lines = []

        # Monitor process for up to 15 seconds for rate limit detection
        start_time = asyncio.get_event_loop().time()
        while (
            gemini_proc.poll() is None
            and (asyncio.get_event_loop().time() - start_time) < 15
        ):  # Reduced from 30s
            # Check if there's new stderr output
            if gemini_proc.stderr and gemini_proc.stderr.readable():
                try:
                    # Non-blocking read of available stderr data
                    import select

                    if select.select([gemini_proc.stderr], [], [], 0.1)[0]:
                        line = gemini_proc.stderr.readline()
                        if line:
                            stderr_lines.append(line)
                            log(f"Gemini stderr: {line.strip()}")

                            # Check for rate limit indicators
                            if (
                                "429" in line
                                or "Quota exceeded" in line
                                or "rateLimitExceeded" in line
                                or "RESOURCE_EXHAUSTED" in line
                            ):
                                log("Rate limit detected in real-time output!")
                                rate_limit_detected = True
                                break
                except:
                    pass

            await asyncio.sleep(0.5)

        # If rate limit detected, terminate and return failure
        if rate_limit_detected:
            log("Terminating gemini process due to rate limit detection")
            gemini_proc.terminate()
            return None

        # If process is still running after 15s, assume it's working and wait for completion
        try:
            stdout, stderr = gemini_proc.communicate(timeout=90)

            log(f"Gemini process completed with return code: {gemini_proc.returncode}")
            if stdout:
                log(f"Gemini stdout: {stdout}")
            if stderr:
                stderr_lines.append(stderr)
                log(f"Gemini stderr (final): {stderr}")

            # Final check for rate limits in all stderr
            all_stderr = "".join(stderr_lines)
            if (
                "429" in all_stderr
                or "Quota exceeded" in all_stderr
                or "rateLimitExceeded" in all_stderr
                or "RESOURCE_EXHAUSTED" in all_stderr
            ):
                log("Rate limit detected in final output")
                return None

            if gemini_proc.returncode == 0:
                log("Gemini process completed successfully.")

                # Parse stdout to extract clean model response
                if stdout:
                    clean_response = self._extract_model_response(stdout)
                    if clean_response:
                        log(f"Clean model response: {clean_response}")
                        return clean_response
                    else:
                        log("No clean model response found in output")
                        return None

                return None
            else:
                log(f"Gemini process failed with return code: {gemini_proc.returncode}")
                return None

        except subprocess.TimeoutExpired:
            log("Gemini process timed out - terminating...")
            gemini_proc.terminate()
            return None

    def _extract_model_response(self, stdout: str) -> Optional[str]:
        """Extract the clean model response from gemini's mixed stdout output."""
        lines = stdout.strip().split("\n")

        # Skip authentication-related lines and find the actual response
        response_lines = []
        found_auth_complete = False

        for line in lines:
            line = line.strip()

            # Skip dotenv messages
            if line.startswith("[dotenv@"):
                continue

            # Skip authentication messages
            if any(
                auth_phrase in line
                for auth_phrase in [
                    "Code Assist login required",
                    "Attempting to open authentication page",
                    "Otherwise navigate to:",
                    "https://accounts.google.com/o/oauth2",
                    "Waiting for authentication...",
                    "Authentication successful",
                ]
            ):
                continue

            # Skip empty lines at the start
            if not line and not response_lines:
                continue

            # If we find "Waiting for authentication...", the next non-empty line is likely the response
            if "Waiting for authentication..." in stdout:
                found_auth_complete = True

            # Collect non-authentication content
            if line:
                response_lines.append(line)

        # Return the cleaned response
        if response_lines:
            # If there's authentication flow, the response is typically the last meaningful content
            if found_auth_complete and response_lines:
                # Find the first line after authentication that looks like a response
                for i, line in enumerate(response_lines):
                    if not any(
                        skip_phrase in line
                        for skip_phrase in [
                            "dotenv",
                            "Code Assist",
                            "Attempting",
                            "navigate",
                            "oauth2",
                            "Waiting",
                        ]
                    ):
                        # Return from this line to the end
                        return "\n".join(response_lines[i:])

            # Fallback: return all non-auth lines
            return "\n".join(response_lines)

        return None


async def call_gemini_cli(
    gemini_args: list[str],
    quit_chrome: bool = False,
    user: Optional[str] = None,
    gemini_executable: str | Path = "gemini",
    verbose: bool = False,
) -> Optional[str]:
    """Core function to call gemini CLI with OAuth automation. Returns clean response text."""
    wrapper = GeminiWrapper(verbose=verbose)

    # Ensure "-y" flag is present
    if "-y" not in gemini_args and "--yes" not in gemini_args:
        gemini_args.insert(0, "-y")

    orig_browser = BrowserManager.get_current_default()
    user_email = UserResolver.resolve_user_email(user)
    log(f"Original default browser: {orig_browser}")

    # Ensure Chrome for Testing is available
    chrome_testing_path = ChromeTestingManager.ensure_available()
    log(f"Chrome for Testing path: {chrome_testing_path}")

    chrome_proc: Optional[subprocess.Popen] = None
    try:
        # Set Chrome for Testing as default browser
        if orig_browser != TESTING_BROWSER_ID:
            log(f"Setting '{TESTING_BROWSER_ID}' as default browser")
            BrowserManager.set_default(TESTING_BROWSER_ID)

        # Launch Chrome if needed
        if ChromeManager.is_cdp_ready():
            log("Chrome CDP already listening — using existing browser.")
        else:
            log("Launching Chrome for Testing with remote debugging…")
            chrome_proc = ChromeManager.launch(chrome_testing_path)

        # Wait for Chrome CDP to be ready
        await ChromeManager.wait_for_cdp()

        # Try running gemini with original args first
        response = await wrapper._try_gemini_with_oauth_and_return_response(
            gemini_args, gemini_executable, user_email
        )

        if response is None:
            # Check if we should retry with flash model
            if "-m" not in gemini_args and "--model" not in gemini_args:
                log("Rate limit detected, retrying with gemini-2.5-flash model...")
                flash_args = ["-m", "gemini-2.5-flash"] + gemini_args
                response = await wrapper._try_gemini_with_oauth_and_return_response(
                    flash_args, gemini_executable, user_email
                )
            else:
                log("Rate limit detected but model already specified, not retrying")

        return response

    finally:
        # Clean up
        log("Cleaning up...")
        if orig_browser != TESTING_BROWSER_ID:
            BrowserManager.set_default(orig_browser)
            log(f"Restored default browser to {orig_browser}")

        if chrome_proc and chrome_proc.poll() is None and quit_chrome:
            log("Quitting Chrome for Testing as requested.")
            chrome_proc.terminate()
            await asyncio.sleep(1)

        log("Script finished.")


def ask(prompt: str, user: Optional[str] = None, verbose: bool = False) -> str:
    """Ask Gemini a question and get a clean text response.

    Args:
        prompt: The question/prompt to ask
        user: Optional specific user email to use for authentication
        verbose: Enable debug logging

    Returns:
        Clean text response from Gemini

    Raises:
        RuntimeError: If authentication or API call fails
    """
    gemini_args = ["-p", prompt]
    response = asyncio.run(
        call_gemini_cli(gemini_args=gemini_args, user=user, verbose=verbose)
    )

    if response is None:
        raise RuntimeError("Failed to get response from Gemini")

    return response


def cli(
    quit_chrome: bool = False,
    verbose: bool = False,
    user: Optional[str] = None,
    gemini_executable: str | Path = "gemini",
    **gemini_args,
) -> None:
    """CLI interface for gemini with automated OAuth via Playwright using Chrome for Testing."""
    # Convert gemini_args dict to CLI argument list
    cli_args = []
    for key, value in gemini_args.items():
        # Use single dash for single char, double dash for multi-char
        flag = f"-{key}" if len(key) == 1 else f"--{key}"
        cli_args.append(flag)

        # Only add value if it's not a boolean True (flags don't need values)
        if value is not True:
            if value is False:
                # Skip false flags entirely
                cli_args.pop()  # Remove the flag we just added
            else:
                cli_args.append(str(value))

    log(f"Running gemini with CLI args: {cli_args}")

    response = asyncio.run(
        call_gemini_cli(
            gemini_args=cli_args,
            quit_chrome=quit_chrome,
            user=user,
            gemini_executable=gemini_executable,
            verbose=verbose,
        )
    )

    # Print response if we got one (for CLI usage)
    if response:
        print(response)


if __name__ == "__main__":
    fire.Fire(cli)
</file>

<file path=".cursorindexingignore">
# Don't index SpecStory auto-save files, but allow explicit context inclusion via @ references
.specstory/**
</file>

<file path=".gitignore">
*_autogen/
.DS_Store
__version__.py
__pycache__/
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
!?*.[Cc]ache/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!**/[Pp]ackages/build/
!Directory.Build.rsp
.*crunch*.local.xml
.axoCover/*
.builds
.cr/personal
.fake/
.history/
.ionide/
.localhistory/
.mfractor/
.ntvs_analysis.dat
.paket/paket.exe
.sass-cache/
.vs/
.vscode
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim_*.settings
*.bim.layout
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
**/[Pp]ackages/*
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
*~
~$*
$tf/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
coverage*.info
coverage*.json
coverage*.xml
csx/
CTestTestfile.cmake
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
ecf/
FakesAssemblies/
FodyWeavers.xsd
Generated_Code/
Generated\ Files/
healthchecksdb
install_manifest.txt
ipch/
Makefile
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
UpgradeLog*.htm
UpgradeLog*.XML
x64/
x86/
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Distribution / packaging
!dist/.gitkeep

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
.ruff_cache/

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
__version__.py
_private
VERSION.txt
</file>

<file path=".pre-commit-config.yaml">
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]
</file>

<file path="AGENTS.md">
## 1. Project Overview

This is a Python package called `geminpy` that appears to be a wrapper/automation tool for Google's Gemini CLI. The codebase includes:
- Old code that needs to be ported is in `work/gemini_wrapper.py`
- That code needs to be ported into `src/geminpy/` and suitably refactored.
- Modern Python packaging with Hatch build system
- Comprehensive testing and linting setup

## 2. Key Commands

### 2.1. Development

```bash
# Run tests
hatch run test

# Run tests with coverage
hatch run test-cov

# Type checking
hatch run type-check

# Linting
hatch run lint

# Format code
hatch run fmt

# Fix code issues (including unsafe fixes)
hatch run fix

# Run a single test
hatch run pytest tests/test_package.py::test_name
```

### 2.2. Environment-specific Commands

```bash
# Run all lint checks
hatch env run lint:all

# Build documentation
hatch env run docs:build

# Run CI tests (with XML coverage)
hatch env run ci:test
```

### 2.3. From .cursorrules - After Python changes run:

```bash
fd -e py -x autoflake {}; fd -e py -x pyupgrade --py311-plus {}; fd -e py -x ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x ruff format --respect-gitignore --target-version py311 {}; python -m pytest;
```

## 3. Architecture

### 3.1. Package Structure
- **src/geminpy/**: Main package source
  - `geminpy.py`: Core module
  - `__version__.py`: Dynamic version from VCS
- **work/**: Old `gemini_wrapper.py` 
- **tests/**: Test suite

### 3.2. Key Dependencies

- Build: Hatchling with hatch-vcs for version control
- Testing: pytest, pytest-cov, pytest-xdist, pytest-benchmark
- Linting: ruff (extensive rules), mypy (strict mode)
- Formatting: isort, pyupgrade, absolufy-imports
- Documentation: sphinx, sphinx-rtd-theme, myst-parser

### 3.3. Chrome Automation Component
The old `work/gemini_wrapper.py` script:
- Automates Google OAuth flow for Gemini CLI
- Manages Chrome for Testing installation
- Uses Playwright for browser automation
- Handles rate limiting with automatic fallback to flash model
- Stores settings in user data directory

We need to port this code into `src/geminpy/` and suitably refactor it.

## 4. Development Guidelines

- Use `uv pip`, never `pip`
- Use `python -m` when running code
- Write clear docstrings and descriptive names
- Use type hints in simplest form (list, dict, | for unions)
- Use f-strings and structural pattern matching
- Add verbose loguru-based logging
- For CLI scripts, use fire & rich
- Include `this_file` record near top of files
- Minimize confirmations, iterate gradually
- Handle failures gracefully with retries/fallbacks
- Modularize repeated logic into single-purpose functions

## 5. Configuration

### 5.1. Tool Configurations (pyproject.toml)
- **Pytest**: Configured with branch coverage, async support
- **Coverage**: Branch coverage enabled, parallel support
- **Mypy**: Strict mode with comprehensive type checking
- **Ruff**: Extensive linting rules covering security, style, complexity
- **Pre-commit**: Hook manager for code quality

### 5.2. Environment Support
- Python 3.10, 3.11, 3.12
- macOS-specific features in Chrome automation tool
- Git repository with VCS-based versioning

## 6. Old Gemini CLI OAuth Automation Wrapper

An automated OAuth wrapper for Google's `gemini` CLI tool on macOS that eliminates the need for manual authentication steps.

## 7. Overview

The `gemini_wrapper.py` script automates the complete Google OAuth flow for the `gemini` CLI by:

1. **Installing Chrome for Testing** if not available (using `@puppeteer/browsers`)
2. **Temporarily switching default browser** to Chrome for Testing (using `macdefaultbrowser`)
3. **Launching Chrome** in remote debugging mode (port 9222)
4. **Running the `gemini` CLI** with your specified arguments
5. **Automating OAuth screens** via Playwright-over-CDP - selecting your account and clicking "Sign in"
6. **Restoring original browser** and optionally quitting Chrome when done

## 8. Key Features

### 8.1. 🔐 **Seamless Authentication**
- Automatically handles Google OAuth flow without manual intervention
- Supports specific user account selection via multiple configuration methods
- Remembers your preferred account across sessions

### 8.2. 🌐 **Smart Browser Management**
- Uses Chrome for Testing to avoid conflicts with your regular browser
- Automatically installs Chrome for Testing if needed
- Temporarily switches default browser for OAuth, then restores it

### 8.3. 🔄 **Rate Limit Handling**
- Detects API rate limits in real-time
- Automatically retries with `gemini-2.5-flash` model when rate limited
- Graceful failure handling with informative error messages

### 8.4. 📊 **Clean Response Extraction**
- Filters out authentication noise from gemini CLI output
- Returns clean model responses for programmatic use
- Preserves original CLI behavior for interactive use

## 9. Installation & Requirements

### 9.1. Prerequisites

**macOS only** - This tool requires macOS (Darwin) due to browser management dependencies.

#### 9.1.1. Install required tools:
```bash
# Install macdefaultbrowser utility
brew install macdefaultbrowser

# Install Playwright browsers (one-time setup)
playwright install chromium
```

#### 9.1.2. Dependencies (auto-installed via uv):
- `fire>=0.5.0` - CLI interface
- `playwright>=1.43.0` - Browser automation
- `requests>=2.31.0` - HTTP requests
- `platformdirs>=4.0.0` - Cross-platform directories
- `loguru>=0.7.0` - Logging

## 10. Usage

### 10.1. CLI Interface (Direct Replacement)

Use exactly like the regular `gemini` CLI, but with automatic OAuth:

```bash
# Ask a question
./gemini_wrapper.py -p "Explain Python decorators"

# Use specific model
./gemini_wrapper.py -m "gemini-pro" -p "Write a Python function"

# With verbose logging
./gemini_wrapper.py --verbose -p "Hello world"

# Quit Chrome when done
./gemini_wrapper.py --quit-chrome -p "What's the weather?"
```

### 10.2. Programmatic Interface

```python
from gemini_wrapper import ask

# Simple question-answer
response = ask("Explain quantum computing in simple terms")
print(response)

# With specific user account
response = ask("Generate Python code", user="myemail@gmail.com")
print(response)

# With debug logging
response = ask("Help with debugging", verbose=True)
print(response)
```

### 10.3. Advanced Usage

```python
import asyncio
from gemini_wrapper import call_gemini_cli

# Full control over gemini arguments
response = await call_gemini_cli(
    gemini_args=["-m", "gemini-pro", "-p", "Your prompt here"],
    user="specific@email.com",
    verbose=True,
    quit_chrome=True
)
```

## 11. User Account Configuration

The wrapper resolves your Google account in this priority order:

1. **`--user` CLI argument**: `./gemini_wrapper.py --user="you@gmail.com" -p "Hello"`
2. **`GEMINI_CLI_USER` environment variable**: `export GEMINI_CLI_USER="you@gmail.com"`
3. **Stored in settings.json**: Automatically saved from previous successful authentications
4. **First available account**: If none specified, uses the first Google account found

## 12. How It Works

### 12.1. Browser Automation Flow

1. **Setup Phase**:
   - Checks if Chrome for Testing is installed, installs if needed
   - Saves current default browser
   - Sets Chrome for Testing as temporary default

2. **Authentication Phase**:
   - Launches Chrome in debugging mode (port 9222)
   - Starts `gemini` CLI which opens OAuth URL in Chrome
   - Playwright connects to Chrome via Chrome DevTools Protocol (CDP)
   - Automatically clicks your account and "Sign in" button

3. **Execution Phase**:
   - Waits for OAuth success redirect
   - Monitors gemini process for completion or rate limits
   - Extracts clean response from mixed CLI output

4. **Cleanup Phase**:
   - Restores original default browser
   - Optionally quits Chrome for Testing
   - Returns clean response text

### 12.2. Rate Limit Handling

When the original request hits rate limits:
```
gemini-wrapper detects: "429" or "Quota exceeded" or "rateLimitExceeded"
↓
Automatically retries with: gemini -m "gemini-2.5-flash" [your-args]
↓
Returns response or fails gracefully
```

## 13. Old File Structure

```
work/
├── gemini_wrapper.py          # Main automation script
└── settings.json              # Auto-generated settings (Chrome path, user email)
```

## 14. Settings Storage

Settings are automatically stored in:
- **Path**: `~/Library/Application Support/com.twardoch.chrometesting/settings.json`
- **Contents**: Chrome for Testing executable path, preferred user email
- **Auto-managed**: No manual editing required

## 15. Troubleshooting

### 15.1. Common Issues

**"Chrome CDP did not become available"**
- Another Chrome instance may be running without `--remote-debugging-port`
- Check if port 9222 is blocked: `curl http://localhost:9222/json/version`
- Look at debug logs: `/tmp/gemini_chrome_stderr.log`

**"macdefaultbrowser utility missing"**
```bash
brew install macdefaultbrowser
```

**Authentication fails**
- Enable verbose mode: `--verbose` to see detailed OAuth flow
- Check screenshots saved to: `oauth_error*.png`
- Verify your Google account has access to Gemini

**Rate limits persist**
- The wrapper automatically tries `gemini-2.5-flash` on rate limits
- Wait a few minutes before retrying
- Check your Gemini API quota in Google Cloud Console

### 15.2. Debug Mode

Enable verbose logging to see the full automation process:

```bash
./gemini_wrapper.py --verbose -p "Your question"
```

This shows:
- Chrome installation and launch details
- Browser switching operations  
- OAuth flow step-by-step
- Gemini CLI output parsing
- Error details and screenshots

## 16. Security Notes

- **Browser isolation**: Uses Chrome for Testing, separate from your regular Chrome
- **Temporary access**: Only switches default browser during authentication
- **Local automation**: All OAuth automation happens locally via CDP
- **No credential storage**: No passwords or tokens are stored, only email preference

The wrapper provides a seamless, secure way to use Google's Gemini CLI without manual OAuth interruptions.

We need to port this code into `src/geminpy/` and suitably refactor it.


Be creative, diligent, critical, relentless & funny!
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package.toml">
# Package configuration
[package]
include_cli = true        # Include CLI boilerplate
include_logging = true    # Include logging setup
use_pydantic = true      # Use Pydantic for data validation
use_rich = true          # Use Rich for terminal output

[features]
mkdocs = false           # Enable MkDocs documentation
vcs = true              # Initialize Git repository
github_actions = true   # Add GitHub Actions workflows
</file>

<file path="pyproject.toml">
# this_file: pyproject.toml
#==============================================================================
# GEMINPY PACKAGE CONFIGURATION
# This pyproject.toml defines the package metadata, dependencies, build system,
# and development environment for the geminpy package.
#==============================================================================

#------------------------------------------------------------------------------
# PROJECT METADATA
# Core package information used by PyPI and package managers.
#------------------------------------------------------------------------------
[project]
name = 'geminpy' # Package name on PyPI
description = 'Automated OAuth wrapper for Google Gemini CLI on macOS' # Short description
readme = 'README.md' # Path to README file
requires-python = '>=3.10' # Minimum Python version
keywords = [
] # Keywords for PyPI search
dynamic = ["version"] # Fields set dynamically at build time

# PyPI classifiers for package categorization
classifiers = [
    'Development Status :: 4 - Beta', # Package maturity level
    'Programming Language :: Python',
    'Programming Language :: Python :: 3.10',
    'Programming Language :: Python :: 3.11',
    'Programming Language :: Python :: 3.12',
    'Programming Language :: Python :: Implementation :: CPython',
    'Programming Language :: Python :: Implementation :: PyPy',
    'Operating System :: OS Independent',
    'License :: OSI Approved :: MIT License',
    'Intended Audience :: Developers',
]

dependencies = [
    "fire>=0.5.0",
    "playwright>=1.43.0",
    "requests>=2.31.0",
    "platformdirs>=4.0.0",
    "loguru>=0.7.0",
    "rich>=13.0.0",
]

# Author information
[[project.authors]]
name = 'Adam Twardoch'
email = 'adam+github@twardoch.com'

# License information
[project.license]
text = 'MIT'

# Project URLs
[project.urls]
Documentation = 'https://github.com/twardoch/geminpy#readme'
Issues = 'https://github.com/twardoch/geminpy/issues'
Source = 'https://github.com/twardoch/geminpy'

#------------------------------------------------------------------------------
# OPTIONAL DEPENDENCIES
# Additional dependencies for optional features, development, and testing.
#------------------------------------------------------------------------------
[project.optional-dependencies]

# Development tools
dev = [
    'pre-commit>=4.1.0', # Pre-commit hook manager - Keep pre-commit as is, update if newer pre-commit version is required
    'ruff>=0.9.7', # Linting and formatting - Keep ruff as is, update if newer ruff version is required
    'mypy>=1.15.0', # Type checking - Keep mypy as is, update if newer mypy version is required
    'absolufy-imports>=0.3.1', # Convert relative imports to absolute - Keep absolufy-imports as is, update if newer absolufy-imports version is required
    'pyupgrade>=3.19.1', # Upgrade Python syntax - Keep pyupgrade as is, update if newer pyupgrade version is required
    'isort>=6.0.1', # Sort imports - Keep isort as is, update if newer isort version is required
]

# Testing tools and frameworks
test = [
    'pytest>=8.3.4', # Testing framework - Keep pytest as is, update if newer pytest version is required
    'pytest-cov>=6.0.0', # Coverage plugin for pytest - Keep pytest-cov as is, update if newer pytest-cov version is required
    'pytest-xdist>=3.6.1', # Parallel test execution - Keep pytest-xdist as is, update if newer pytest-xdist version is required
    'pytest-benchmark[histogram]>=5.1.0', # Benchmarking plugin - Keep pytest-benchmark as is, update if newer pytest-benchmark version is required
    'pytest-asyncio>=0.25.3', # Async test support - Keep pytest-asyncio as is, update if newer pytest-asyncio version is required
    'coverage[toml]>=7.6.12',
]

docs = [
    "sphinx>=7.2.6",
    "sphinx-rtd-theme>=2.0.0",
    "sphinx-autodoc-typehints>=2.0.0",
    "myst-parser>=3.0.0", # Markdown support in Sphinx
]

# All optional dependencies combined
all = [
]

#------------------------------------------------------------------------------
# COMMAND-LINE SCRIPTS
# Entry points for command-line executables installed with the package.
#------------------------------------------------------------------------------
[project.scripts]
geminpy = "geminpy.cli:main"

#------------------------------------------------------------------------------
# BUILD SYSTEM CONFIGURATION
# Defines the tools required to build the package and the build backend.
#------------------------------------------------------------------------------
[build-system]
# Hatchling is a modern build backend for Python packaging
# hatch-vcs integrates with version control systems for versioning
requires = [
    'hatchling>=1.27.0', # Keep hatchling as is, update if newer hatchling version is required
    'hatch-vcs>=0.4.0', # Keep hatch-vcs as is, update if newer hatch-vcs version is required
]
build-backend = 'hatchling.build' # Specifies Hatchling as the build backend


#------------------------------------------------------------------------------
# HATCH BUILD CONFIGURATION
# Configures the build process, specifying which packages to include and
# how to handle versioning.
#------------------------------------------------------------------------------
[tool.hatch.build]
# Include package data files
include = [
    "src/geminpy/py.typed", # For better type checking support
    "src/geminpy/data/**/*", # Include data files if any

]
exclude = ["**/__pycache__", "**/.pytest_cache", "**/.mypy_cache"]

[tool.hatch.build.targets.wheel]
packages = ["src/geminpy"]
reproducible = true


# Version control system hook configuration
# Automatically updates the version file from git tags
[tool.hatch.build.hooks.vcs]
version-file = "src/geminpy/__version__.py"

# Version source configuration
[tool.hatch.version]
source = 'vcs' # Get version from git tags or other VCS info

# Metadata handling configuration
[tool.hatch.metadata]
allow-direct-references = true # Allow direct references in metadata (useful for local dependencies)


#------------------------------------------------------------------------------
# DEVELOPMENT ENVIRONMENTS

[tool.hatch.envs.default]
features = ['dev', 'test', 'all']
dependencies = [
]

# Commands available in the default environment
[tool.hatch.envs.default.scripts]
# Run tests with optional arguments
test = 'pytest {args:tests}'
# Run tests with coverage reporting
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/geminpy --cov=tests {args:tests}"
# Run type checking
type-check = "mypy src/geminpy tests"
# Run linting and formatting
lint = ["ruff check src/geminpy tests", "ruff format --respect-gitignore src/geminpy tests"]
# Format and fix style issues
fmt = ["ruff format --respect-gitignore src/geminpy tests", "ruff check --fix src/geminpy tests"]
fix = ["ruff check --fix --unsafe-fixes src/geminpy tests", "ruff format --respect-gitignore src/geminpy tests"]

# Matrix configuration to test across multiple Python versions

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

#------------------------------------------------------------------------------
# SPECIALIZED ENVIRONMENTS
# Additional environments for specific development tasks.
#------------------------------------------------------------------------------

# Dedicated environment for linting and code quality checks
[tool.hatch.envs.lint]
detached = true # Create a separate, isolated environment
features = ['dev'] # Use dev extras  dependencies 

# Linting environment commands
[tool.hatch.envs.lint.scripts]
# Type checking with automatic type installation
typing = "mypy --install-types --non-interactive {args:src/geminpy tests}"
# Check style and format code
style = ["ruff check {args:.}", "ruff format --respect-gitignore {args:.}"]
# Format and fix style issues
fmt = ["ruff format --respect-gitignore {args:.}", "ruff check --fix {args:.}"]
fix = ["ruff check --fix --unsafe-fixes {args:.}", "ruff format --respect-gitignore {args:.}"]
# Run all ops
all = ["style", "typing", "fix"]

# Dedicated environment for testing
[tool.hatch.envs.test]
features = ['test'] # Use test extras as dependencies

# Testing environment commands
[tool.hatch.envs.test.scripts]
# Run tests in parallel
test = "python -m pytest -n auto {args:tests}"
# Run tests with coverage in parallel
test-cov = "python -m pytest -n auto --cov-report=term-missing --cov-config=pyproject.toml --cov=src/geminpy --cov=tests {args:tests}"
# Run benchmarks
bench = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only"
# Run benchmarks and save results
bench-save = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only --benchmark-json=benchmark/results.json"

# Documentation environment
[tool.hatch.envs.docs]
features = ['docs']

# Documentation environment commands
[tool.hatch.envs.docs.scripts]
build = "sphinx-build -b html docs/source docs/build"

# GitHub Actions workflow configuration
[tool.hatch.envs.ci]
features = ['test']


[tool.hatch.envs.ci.scripts]
test = "pytest --cov=src/geminpy --cov-report=xml"


#------------------------------------------------------------------------------
# CODE QUALITY TOOLS
# Configuration for linting, formatting, and code quality enforcement.
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# COVERAGE CONFIGURATION
# Settings for test coverage measurement and reporting.
#------------------------------------------------------------------------------

# Path mapping for coverage in different environments
[tool.coverage.paths]
geminpy = ["src/geminpy", "*/geminpy/src/geminpy"]
tests = ["tests", "*/geminpy/tests"]

# Coverage report configuration
[tool.coverage.report]
# Lines to exclude from coverage reporting
exclude_lines = [
    'no cov', # Custom marker to skip coverage
    'if __name__ == .__main__.:', # Script execution guard
    'if TYPE_CHECKING:', # Type checking imports and code
    'pass', # Empty pass statements
    'raise NotImplementedError', # Unimplemented method placeholders
    'raise ImportError', # Import error handling
    'except ImportError', # Import error handling
    'except KeyError', # Common error handling
    'except AttributeError', # Common error handling
    'except NotImplementedError', # Common error handling
]

[tool.coverage.run]
source_pkgs = ["geminpy", "tests"]
branch = true # Measure branch coverage (if/else statements)
parallel = true # Support parallel test execution
omit = [
    "src/geminpy/__about__.py",
]

#------------------------------------------------------------------------------
# MYPY CONFIGURATION
# Configuration for type checking with mypy.
#------------------------------------------------------------------------------

[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true

[[tool.mypy.overrides]]
module = ["tests.*"]
disallow_untyped_defs = false
disallow_incomplete_defs = false

#------------------------------------------------------------------------------
# PYTEST CONFIGURATION
# Configuration for pytest, including markers, options, and benchmark settings.
#------------------------------------------------------------------------------

[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase"
asyncio_mode = "auto"
asyncio_default_fixture_loop_scope = "function"
console_output_style = "progress"
filterwarnings = ["ignore::DeprecationWarning", "ignore::UserWarning"]
log_cli = true
log_cli_level = "INFO"
markers = [
    "benchmark: marks tests as benchmarks (select with '-m benchmark')",
    "unit: mark a test as a unit test",
    "integration: mark a test as an integration test",
    "permutation: tests for permutation functionality", 
    "parameter: tests for parameter parsing",
    "prompt: tests for prompt parsing",
]
norecursedirs = [
    ".*",
    "build",
    "dist", 
    "venv",
    "__pycache__",
    "*.egg-info",
    "_private",
]
python_classes = ["Test*"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
testpaths = ["tests"]

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",    # Minimum time
    "max",    # Maximum time
    "mean",   # Mean time
    "stddev", # Standard deviation
    "median", # Median time
    "iqr",    # Inter-quartile range
    "ops",    # Operations per second
    "rounds", # Number of rounds
]

#------------------------------------------------------------------------------
# RUFF CONFIGURATION
# Configuration for Ruff, including linter and formatter settings.
#------------------------------------------------------------------------------ 

# Ruff linter and formatter configuration
[tool.ruff]
target-version = "py310"
line-length = 120

# Linting rules configuration
[tool.ruff.lint]
# Rule sets to enable, organized by category
select = [
    # flake8 plugins and extensions
    'A', # flake8-builtins: checks for shadowed builtins
    'ARG', # flake8-unused-arguments: checks for unused function arguments
    'ASYNC', # flake8-async: checks for async/await issues
    'B', # flake8-bugbear: finds likely bugs and design problems
    'C', # flake8-comprehensions: helps write better list/dict comprehensions
    'DTZ', # flake8-datetimez: checks for datetime timezone issues
    'E', # pycodestyle errors: PEP 8 style guide errors
    'EM', # flake8-errmsg: checks for better error messages
    'F', # pyflakes: detects various errors
    'FBT', # flake8-boolean-trap: checks for boolean traps in function signatures
    'I', # isort: sorts imports
    'ICN', # flake8-import-conventions: checks for import conventions
    'ISC', # flake8-implicit-str-concat: checks for implicit string concatenation
    'LOG', # flake8-logging: checks for logging issues
    'N', # pep8-naming: checks naming conventions
    'PLC', # pylint convention: checks for convention issues
    'PLE', # pylint error: checks for errors
    'PLR', # pylint refactor: suggests refactors
    'PLW', # pylint warning: checks for suspicious code
    'PT', # flake8-pytest-style: checks pytest-specific style
    'PTH', # flake8-use-pathlib: checks for stdlib path usage vs pathlib
    'PYI', # flake8-pyi: checks stub files
    'RET', # flake8-return: checks return statement consistency
    'RSE', # flake8-raise: checks raise statements
    'RUF', # Ruff-specific rules
    'S', # flake8-bandit: checks for security issues
    'SIM', # flake8-simplify: checks for code simplification opportunities
    'T', # flake8-print: checks for print statements
    'TCH', # flake8-type-checking: helps with type-checking
    'TID', # flake8-tidy-imports: checks for tidy import statements
    'UP', # pyupgrade: checks for opportunities to use newer Python features
    'W', # pycodestyle warnings: PEP 8 style guide warnings
    'YTT', # flake8-2020: checks for misuse of sys.version or sys.version_info

]
# Rules to ignore (with reasons)
ignore = [
    'B027', # Empty method in abstract base class - sometimes needed for interfaces
    'C901', # Function is too complex - sometimes complexity is necessary
    'FBT003', # Boolean positional argument in function definition - sometimes unavoidable
    'PLR0911', # Too many return statements - sometimes needed for readability
    'PLR0912', # Too many branches - sometimes needed for complex logic
    'PLR0913', # Too many arguments - sometimes needed in APIs
    'PLR0915', # Too many statements - sometimes needed for comprehensive functions
    'PLR1714', # Consider merging multiple comparisons - sometimes less readable
    'PLW0603', # Using the global statement - sometimes necessary
    'PT013', # Pytest explicit test parameter - sometimes clearer
    'PTH123', # Path traversal - sometimes needed
    'PYI056', # Calling open() in pyi file - sometimes needed in type stubs
    'S105', # Possible hardcoded password - often false positives
    'S106', # Possible hardcoded password - often false positives
    'S107', # Possible hardcoded password - often false positives
    'S110', # try-except-pass - sometimes valid for suppressing exceptions
    'SIM102'
    # Nested if statements - sometimes more readable than combined conditions
]
# Rules that should not be automatically fixed
unfixable = [
    'F401', # Don't automatically remove unused imports - may be needed later

]
# Configure extend-exclude to ignore specific directories
extend-exclude = [".git", ".venv", "venv", "dist", "build"]

# isort configuration within Ruff
[tool.ruff.lint.isort]
known-first-party = ['geminpy'] # Treat as first-party imports for sorting

# flake8-tidy-imports configuration within Ruff
[tool.ruff.lint.flake8-tidy-imports]
ban-relative-imports = 'all' # Ban all relative imports for consistency

# Per-file rule exceptions
[tool.ruff.lint.per-file-ignores]
# Tests can use magic values, assertions, and relative imports
'tests/**/*' = [
    'PLR2004', # Allow magic values in tests for readability
    'S101', # Allow assertions in tests
    'TID252'
    # Allow relative imports in tests for convenience
]
</file>

<file path=".cursorrules">
## 1. Project Overview

This is a Python package called `geminpy` that appears to be a wrapper/automation tool for Google's Gemini CLI. The codebase includes:
- Old code that needs to be ported is in `work/gemini_wrapper.py`
- That code needs to be ported into `src/geminpy/` and suitably refactored.
- Modern Python packaging with Hatch build system
- Comprehensive testing and linting setup

## 2. Key Commands

### 2.1. Development

```bash
# Run tests
hatch run test

# Run tests with coverage
hatch run test-cov

# Type checking
hatch run type-check

# Linting
hatch run lint

# Format code
hatch run fmt

# Fix code issues (including unsafe fixes)
hatch run fix

# Run a single test
hatch run pytest tests/test_package.py::test_name
```

### 2.2. Environment-specific Commands

```bash
# Run all lint checks
hatch env run lint:all

# Build documentation
hatch env run docs:build

# Run CI tests (with XML coverage)
hatch env run ci:test
```

### 2.3. From .cursorrules - After Python changes run:

```bash
fd -e py -x autoflake {}; fd -e py -x pyupgrade --py311-plus {}; fd -e py -x ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x ruff format --respect-gitignore --target-version py311 {}; python -m pytest;
```

## 3. Architecture

### 3.1. Package Structure
- **src/geminpy/**: Main package source
  - `geminpy.py`: Core module
  - `__version__.py`: Dynamic version from VCS
- **work/**: Old `gemini_wrapper.py` 
- **tests/**: Test suite

### 3.2. Key Dependencies

- Build: Hatchling with hatch-vcs for version control
- Testing: pytest, pytest-cov, pytest-xdist, pytest-benchmark
- Linting: ruff (extensive rules), mypy (strict mode)
- Formatting: isort, pyupgrade, absolufy-imports
- Documentation: sphinx, sphinx-rtd-theme, myst-parser

### 3.3. Chrome Automation Component
The old `work/gemini_wrapper.py` script:
- Automates Google OAuth flow for Gemini CLI
- Manages Chrome for Testing installation
- Uses Playwright for browser automation
- Handles rate limiting with automatic fallback to flash model
- Stores settings in user data directory

We need to port this code into `src/geminpy/` and suitably refactor it.

## 4. Development Guidelines

- Use `uv pip`, never `pip`
- Use `python -m` when running code
- Write clear docstrings and descriptive names
- Use type hints in simplest form (list, dict, | for unions)
- Use f-strings and structural pattern matching
- Add verbose loguru-based logging
- For CLI scripts, use fire & rich
- Include `this_file` record near top of files
- Minimize confirmations, iterate gradually
- Handle failures gracefully with retries/fallbacks
- Modularize repeated logic into single-purpose functions

## 5. Configuration

### 5.1. Tool Configurations (pyproject.toml)
- **Pytest**: Configured with branch coverage, async support
- **Coverage**: Branch coverage enabled, parallel support
- **Mypy**: Strict mode with comprehensive type checking
- **Ruff**: Extensive linting rules covering security, style, complexity
- **Pre-commit**: Hook manager for code quality

### 5.2. Environment Support
- Python 3.10, 3.11, 3.12
- macOS-specific features in Chrome automation tool
- Git repository with VCS-based versioning

## 6. Old Gemini CLI OAuth Automation Wrapper

An automated OAuth wrapper for Google's `gemini` CLI tool on macOS that eliminates the need for manual authentication steps.

## 7. Overview

The `gemini_wrapper.py` script automates the complete Google OAuth flow for the `gemini` CLI by:

1. **Installing Chrome for Testing** if not available (using `@puppeteer/browsers`)
2. **Temporarily switching default browser** to Chrome for Testing (using `macdefaultbrowser`)
3. **Launching Chrome** in remote debugging mode (port 9222)
4. **Running the `gemini` CLI** with your specified arguments
5. **Automating OAuth screens** via Playwright-over-CDP - selecting your account and clicking "Sign in"
6. **Restoring original browser** and optionally quitting Chrome when done

## 8. Key Features

### 8.1. 🔐 **Seamless Authentication**
- Automatically handles Google OAuth flow without manual intervention
- Supports specific user account selection via multiple configuration methods
- Remembers your preferred account across sessions

### 8.2. 🌐 **Smart Browser Management**
- Uses Chrome for Testing to avoid conflicts with your regular browser
- Automatically installs Chrome for Testing if needed
- Temporarily switches default browser for OAuth, then restores it

### 8.3. 🔄 **Rate Limit Handling**
- Detects API rate limits in real-time
- Automatically retries with `gemini-2.5-flash` model when rate limited
- Graceful failure handling with informative error messages

### 8.4. 📊 **Clean Response Extraction**
- Filters out authentication noise from gemini CLI output
- Returns clean model responses for programmatic use
- Preserves original CLI behavior for interactive use

## 9. Installation & Requirements

### 9.1. Prerequisites

**macOS only** - This tool requires macOS (Darwin) due to browser management dependencies.

#### 9.1.1. Install required tools:
```bash
# Install macdefaultbrowser utility
brew install macdefaultbrowser

# Install Playwright browsers (one-time setup)
playwright install chromium
```

#### 9.1.2. Dependencies (auto-installed via uv):
- `fire>=0.5.0` - CLI interface
- `playwright>=1.43.0` - Browser automation
- `requests>=2.31.0` - HTTP requests
- `platformdirs>=4.0.0` - Cross-platform directories
- `loguru>=0.7.0` - Logging

## 10. Usage

### 10.1. CLI Interface (Direct Replacement)

Use exactly like the regular `gemini` CLI, but with automatic OAuth:

```bash
# Ask a question
./gemini_wrapper.py -p "Explain Python decorators"

# Use specific model
./gemini_wrapper.py -m "gemini-pro" -p "Write a Python function"

# With verbose logging
./gemini_wrapper.py --verbose -p "Hello world"

# Quit Chrome when done
./gemini_wrapper.py --quit-chrome -p "What's the weather?"
```

### 10.2. Programmatic Interface

```python
from gemini_wrapper import ask

# Simple question-answer
response = ask("Explain quantum computing in simple terms")
print(response)

# With specific user account
response = ask("Generate Python code", user="myemail@gmail.com")
print(response)

# With debug logging
response = ask("Help with debugging", verbose=True)
print(response)
```

### 10.3. Advanced Usage

```python
import asyncio
from gemini_wrapper import call_gemini_cli

# Full control over gemini arguments
response = await call_gemini_cli(
    gemini_args=["-m", "gemini-pro", "-p", "Your prompt here"],
    user="specific@email.com",
    verbose=True,
    quit_chrome=True
)
```

## 11. User Account Configuration

The wrapper resolves your Google account in this priority order:

1. **`--user` CLI argument**: `./gemini_wrapper.py --user="you@gmail.com" -p "Hello"`
2. **`GEMINI_CLI_USER` environment variable**: `export GEMINI_CLI_USER="you@gmail.com"`
3. **Stored in settings.json**: Automatically saved from previous successful authentications
4. **First available account**: If none specified, uses the first Google account found

## 12. How It Works

### 12.1. Browser Automation Flow

1. **Setup Phase**:
   - Checks if Chrome for Testing is installed, installs if needed
   - Saves current default browser
   - Sets Chrome for Testing as temporary default

2. **Authentication Phase**:
   - Launches Chrome in debugging mode (port 9222)
   - Starts `gemini` CLI which opens OAuth URL in Chrome
   - Playwright connects to Chrome via Chrome DevTools Protocol (CDP)
   - Automatically clicks your account and "Sign in" button

3. **Execution Phase**:
   - Waits for OAuth success redirect
   - Monitors gemini process for completion or rate limits
   - Extracts clean response from mixed CLI output

4. **Cleanup Phase**:
   - Restores original default browser
   - Optionally quits Chrome for Testing
   - Returns clean response text

### 12.2. Rate Limit Handling

When the original request hits rate limits:
```
gemini-wrapper detects: "429" or "Quota exceeded" or "rateLimitExceeded"
↓
Automatically retries with: gemini -m "gemini-2.5-flash" [your-args]
↓
Returns response or fails gracefully
```

## 13. Old File Structure

```
work/
├── gemini_wrapper.py          # Main automation script
└── settings.json              # Auto-generated settings (Chrome path, user email)
```

## 14. Settings Storage

Settings are automatically stored in:
- **Path**: `~/Library/Application Support/com.twardoch.chrometesting/settings.json`
- **Contents**: Chrome for Testing executable path, preferred user email
- **Auto-managed**: No manual editing required

## 15. Troubleshooting

### 15.1. Common Issues

**"Chrome CDP did not become available"**
- Another Chrome instance may be running without `--remote-debugging-port`
- Check if port 9222 is blocked: `curl http://localhost:9222/json/version`
- Look at debug logs: `/tmp/gemini_chrome_stderr.log`

**"macdefaultbrowser utility missing"**
```bash
brew install macdefaultbrowser
```

**Authentication fails**
- Enable verbose mode: `--verbose` to see detailed OAuth flow
- Check screenshots saved to: `oauth_error*.png`
- Verify your Google account has access to Gemini

**Rate limits persist**
- The wrapper automatically tries `gemini-2.5-flash` on rate limits
- Wait a few minutes before retrying
- Check your Gemini API quota in Google Cloud Console

### 15.2. Debug Mode

Enable verbose logging to see the full automation process:

```bash
./gemini_wrapper.py --verbose -p "Your question"
```

This shows:
- Chrome installation and launch details
- Browser switching operations  
- OAuth flow step-by-step
- Gemini CLI output parsing
- Error details and screenshots

## 16. Security Notes

- **Browser isolation**: Uses Chrome for Testing, separate from your regular Chrome
- **Temporary access**: Only switches default browser during authentication
- **Local automation**: All OAuth automation happens locally via CDP
- **No credential storage**: No passwords or tokens are stored, only email preference

The wrapper provides a seamless, secure way to use Google's Gemini CLI without manual OAuth interruptions.

We need to port this code into `src/geminpy/` and suitably refactor it.


Be creative, diligent, critical, relentless & funny!
</file>

<file path="CLAUDE.md">
## 1. Project Overview

This is a Python package called `geminpy` that appears to be a wrapper/automation tool for Google's Gemini CLI. The codebase includes:
- Old code that needs to be ported is in `work/gemini_wrapper.py`
- That code needs to be ported into `src/geminpy/` and suitably refactored.
- Modern Python packaging with Hatch build system
- Comprehensive testing and linting setup

## 2. Key Commands

### 2.1. Development

```bash
# Run tests
hatch run test

# Run tests with coverage
hatch run test-cov

# Type checking
hatch run type-check

# Linting
hatch run lint

# Format code
hatch run fmt

# Fix code issues (including unsafe fixes)
hatch run fix

# Run a single test
hatch run pytest tests/test_package.py::test_name
```

### 2.2. Environment-specific Commands

```bash
# Run all lint checks
hatch env run lint:all

# Build documentation
hatch env run docs:build

# Run CI tests (with XML coverage)
hatch env run ci:test
```

### 2.3. From .cursorrules - After Python changes run:

```bash
fd -e py -x autoflake {}; fd -e py -x pyupgrade --py311-plus {}; fd -e py -x ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x ruff format --respect-gitignore --target-version py311 {}; python -m pytest;
```

## 3. Architecture

### 3.1. Package Structure
- **src/geminpy/**: Main package source
  - `geminpy.py`: Core module
  - `__version__.py`: Dynamic version from VCS
- **work/**: Old `gemini_wrapper.py` 
- **tests/**: Test suite

### 3.2. Key Dependencies

- Build: Hatchling with hatch-vcs for version control
- Testing: pytest, pytest-cov, pytest-xdist, pytest-benchmark
- Linting: ruff (extensive rules), mypy (strict mode)
- Formatting: isort, pyupgrade, absolufy-imports
- Documentation: sphinx, sphinx-rtd-theme, myst-parser

### 3.3. Chrome Automation Component
The old `work/gemini_wrapper.py` script:
- Automates Google OAuth flow for Gemini CLI
- Manages Chrome for Testing installation
- Uses Playwright for browser automation
- Handles rate limiting with automatic fallback to flash model
- Stores settings in user data directory

We need to port this code into `src/geminpy/` and suitably refactor it.

## 4. Development Guidelines

- Use `uv pip`, never `pip`
- Use `python -m` when running code
- Write clear docstrings and descriptive names
- Use type hints in simplest form (list, dict, | for unions)
- Use f-strings and structural pattern matching
- Add verbose loguru-based logging
- For CLI scripts, use fire & rich
- Include `this_file` record near top of files
- Minimize confirmations, iterate gradually
- Handle failures gracefully with retries/fallbacks
- Modularize repeated logic into single-purpose functions

## 5. Configuration

### 5.1. Tool Configurations (pyproject.toml)
- **Pytest**: Configured with branch coverage, async support
- **Coverage**: Branch coverage enabled, parallel support
- **Mypy**: Strict mode with comprehensive type checking
- **Ruff**: Extensive linting rules covering security, style, complexity
- **Pre-commit**: Hook manager for code quality

### 5.2. Environment Support
- Python 3.10, 3.11, 3.12
- macOS-specific features in Chrome automation tool
- Git repository with VCS-based versioning

## 6. Old Gemini CLI OAuth Automation Wrapper

An automated OAuth wrapper for Google's `gemini` CLI tool on macOS that eliminates the need for manual authentication steps.

## 7. Overview

The `gemini_wrapper.py` script automates the complete Google OAuth flow for the `gemini` CLI by:

1. **Installing Chrome for Testing** if not available (using `@puppeteer/browsers`)
2. **Temporarily switching default browser** to Chrome for Testing (using `macdefaultbrowser`)
3. **Launching Chrome** in remote debugging mode (port 9222)
4. **Running the `gemini` CLI** with your specified arguments
5. **Automating OAuth screens** via Playwright-over-CDP - selecting your account and clicking "Sign in"
6. **Restoring original browser** and optionally quitting Chrome when done

## 8. Key Features

### 8.1. 🔐 **Seamless Authentication**
- Automatically handles Google OAuth flow without manual intervention
- Supports specific user account selection via multiple configuration methods
- Remembers your preferred account across sessions

### 8.2. 🌐 **Smart Browser Management**
- Uses Chrome for Testing to avoid conflicts with your regular browser
- Automatically installs Chrome for Testing if needed
- Temporarily switches default browser for OAuth, then restores it

### 8.3. 🔄 **Rate Limit Handling**
- Detects API rate limits in real-time
- Automatically retries with `gemini-2.5-flash` model when rate limited
- Graceful failure handling with informative error messages

### 8.4. 📊 **Clean Response Extraction**
- Filters out authentication noise from gemini CLI output
- Returns clean model responses for programmatic use
- Preserves original CLI behavior for interactive use

## 9. Installation & Requirements

### 9.1. Prerequisites

**macOS only** - This tool requires macOS (Darwin) due to browser management dependencies.

#### 9.1.1. Install required tools:
```bash
# Install macdefaultbrowser utility
brew install macdefaultbrowser

# Install Playwright browsers (one-time setup)
playwright install chromium
```

#### 9.1.2. Dependencies (auto-installed via uv):
- `fire>=0.5.0` - CLI interface
- `playwright>=1.43.0` - Browser automation
- `requests>=2.31.0` - HTTP requests
- `platformdirs>=4.0.0` - Cross-platform directories
- `loguru>=0.7.0` - Logging

## 10. Usage

### 10.1. CLI Interface (Direct Replacement)

Use exactly like the regular `gemini` CLI, but with automatic OAuth:

```bash
# Ask a question
./gemini_wrapper.py -p "Explain Python decorators"

# Use specific model
./gemini_wrapper.py -m "gemini-pro" -p "Write a Python function"

# With verbose logging
./gemini_wrapper.py --verbose -p "Hello world"

# Quit Chrome when done
./gemini_wrapper.py --quit-chrome -p "What's the weather?"
```

### 10.2. Programmatic Interface

```python
from gemini_wrapper import ask

# Simple question-answer
response = ask("Explain quantum computing in simple terms")
print(response)

# With specific user account
response = ask("Generate Python code", user="myemail@gmail.com")
print(response)

# With debug logging
response = ask("Help with debugging", verbose=True)
print(response)
```

### 10.3. Advanced Usage

```python
import asyncio
from gemini_wrapper import call_gemini_cli

# Full control over gemini arguments
response = await call_gemini_cli(
    gemini_args=["-m", "gemini-pro", "-p", "Your prompt here"],
    user="specific@email.com",
    verbose=True,
    quit_chrome=True
)
```

## 11. User Account Configuration

The wrapper resolves your Google account in this priority order:

1. **`--user` CLI argument**: `./gemini_wrapper.py --user="you@gmail.com" -p "Hello"`
2. **`GEMINI_CLI_USER` environment variable**: `export GEMINI_CLI_USER="you@gmail.com"`
3. **Stored in settings.json**: Automatically saved from previous successful authentications
4. **First available account**: If none specified, uses the first Google account found

## 12. How It Works

### 12.1. Browser Automation Flow

1. **Setup Phase**:
   - Checks if Chrome for Testing is installed, installs if needed
   - Saves current default browser
   - Sets Chrome for Testing as temporary default

2. **Authentication Phase**:
   - Launches Chrome in debugging mode (port 9222)
   - Starts `gemini` CLI which opens OAuth URL in Chrome
   - Playwright connects to Chrome via Chrome DevTools Protocol (CDP)
   - Automatically clicks your account and "Sign in" button

3. **Execution Phase**:
   - Waits for OAuth success redirect
   - Monitors gemini process for completion or rate limits
   - Extracts clean response from mixed CLI output

4. **Cleanup Phase**:
   - Restores original default browser
   - Optionally quits Chrome for Testing
   - Returns clean response text

### 12.2. Rate Limit Handling

When the original request hits rate limits:
```
gemini-wrapper detects: "429" or "Quota exceeded" or "rateLimitExceeded"
↓
Automatically retries with: gemini -m "gemini-2.5-flash" [your-args]
↓
Returns response or fails gracefully
```

## 13. Old File Structure

```
work/
├── gemini_wrapper.py          # Main automation script
└── settings.json              # Auto-generated settings (Chrome path, user email)
```

## 14. Settings Storage

Settings are automatically stored in:
- **Path**: `~/Library/Application Support/com.twardoch.chrometesting/settings.json`
- **Contents**: Chrome for Testing executable path, preferred user email
- **Auto-managed**: No manual editing required

## 15. Troubleshooting

### 15.1. Common Issues

**"Chrome CDP did not become available"**
- Another Chrome instance may be running without `--remote-debugging-port`
- Check if port 9222 is blocked: `curl http://localhost:9222/json/version`
- Look at debug logs: `/tmp/gemini_chrome_stderr.log`

**"macdefaultbrowser utility missing"**
```bash
brew install macdefaultbrowser
```

**Authentication fails**
- Enable verbose mode: `--verbose` to see detailed OAuth flow
- Check screenshots saved to: `oauth_error*.png`
- Verify your Google account has access to Gemini

**Rate limits persist**
- The wrapper automatically tries `gemini-2.5-flash` on rate limits
- Wait a few minutes before retrying
- Check your Gemini API quota in Google Cloud Console

### 15.2. Debug Mode

Enable verbose logging to see the full automation process:

```bash
./gemini_wrapper.py --verbose -p "Your question"
```

This shows:
- Chrome installation and launch details
- Browser switching operations  
- OAuth flow step-by-step
- Gemini CLI output parsing
- Error details and screenshots

## 16. Security Notes

- **Browser isolation**: Uses Chrome for Testing, separate from your regular Chrome
- **Temporary access**: Only switches default browser during authentication
- **Local automation**: All OAuth automation happens locally via CDP
- **No credential storage**: No passwords or tokens are stored, only email preference

The wrapper provides a seamless, secure way to use Google's Gemini CLI without manual OAuth interruptions.

We need to port this code into `src/geminpy/` and suitably refactor it.


Be creative, diligent, critical, relentless & funny!
</file>

<file path="README.md">
## 1. Project Overview

This is a Python package called `geminpy` that appears to be a wrapper/automation tool for Google's Gemini CLI. The codebase includes:
- Old code that needs to be ported is in `work/gemini_wrapper.py`
- That code needs to be ported into `src/geminpy/` and suitably refactored.
- Modern Python packaging with Hatch build system
- Comprehensive testing and linting setup

## 2. Key Commands

### 2.1. Development

```bash
# Run tests
hatch run test

# Run tests with coverage
hatch run test-cov

# Type checking
hatch run type-check

# Linting
hatch run lint

# Format code
hatch run fmt

# Fix code issues (including unsafe fixes)
hatch run fix

# Run a single test
hatch run pytest tests/test_package.py::test_name
```

### 2.2. Environment-specific Commands

```bash
# Run all lint checks
hatch env run lint:all

# Build documentation
hatch env run docs:build

# Run CI tests (with XML coverage)
hatch env run ci:test
```

### 2.3. From .cursorrules - After Python changes run:

```bash
fd -e py -x autoflake {}; fd -e py -x pyupgrade --py311-plus {}; fd -e py -x ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x ruff format --respect-gitignore --target-version py311 {}; python -m pytest;
```

## 3. Architecture

### 3.1. Package Structure
- **src/geminpy/**: Main package source
  - `geminpy.py`: Core module
  - `__version__.py`: Dynamic version from VCS
- **work/**: Old `gemini_wrapper.py` 
- **tests/**: Test suite

### 3.2. Key Dependencies

- Build: Hatchling with hatch-vcs for version control
- Testing: pytest, pytest-cov, pytest-xdist, pytest-benchmark
- Linting: ruff (extensive rules), mypy (strict mode)
- Formatting: isort, pyupgrade, absolufy-imports
- Documentation: sphinx, sphinx-rtd-theme, myst-parser

### 3.3. Chrome Automation Component
The old `work/gemini_wrapper.py` script:
- Automates Google OAuth flow for Gemini CLI
- Manages Chrome for Testing installation
- Uses Playwright for browser automation
- Handles rate limiting with automatic fallback to flash model
- Stores settings in user data directory

We need to port this code into `src/geminpy/` and suitably refactor it.

## 4. Development Guidelines

- Use `uv pip`, never `pip`
- Use `python -m` when running code
- Write clear docstrings and descriptive names
- Use type hints in simplest form (list, dict, | for unions)
- Use f-strings and structural pattern matching
- Add verbose loguru-based logging
- For CLI scripts, use fire & rich
- Include `this_file` record near top of files
- Minimize confirmations, iterate gradually
- Handle failures gracefully with retries/fallbacks
- Modularize repeated logic into single-purpose functions

## 5. Configuration

### 5.1. Tool Configurations (pyproject.toml)
- **Pytest**: Configured with branch coverage, async support
- **Coverage**: Branch coverage enabled, parallel support
- **Mypy**: Strict mode with comprehensive type checking
- **Ruff**: Extensive linting rules covering security, style, complexity
- **Pre-commit**: Hook manager for code quality

### 5.2. Environment Support
- Python 3.10, 3.11, 3.12
- macOS-specific features in Chrome automation tool
- Git repository with VCS-based versioning

## 6. Old Gemini CLI OAuth Automation Wrapper

An automated OAuth wrapper for Google's `gemini` CLI tool on macOS that eliminates the need for manual authentication steps.

## 7. Overview

The `gemini_wrapper.py` script automates the complete Google OAuth flow for the `gemini` CLI by:

1. **Installing Chrome for Testing** if not available (using `@puppeteer/browsers`)
2. **Temporarily switching default browser** to Chrome for Testing (using `macdefaultbrowser`)
3. **Launching Chrome** in remote debugging mode (port 9222)
4. **Running the `gemini` CLI** with your specified arguments
5. **Automating OAuth screens** via Playwright-over-CDP - selecting your account and clicking "Sign in"
6. **Restoring original browser** and optionally quitting Chrome when done

## 8. Key Features

### 8.1. 🔐 **Seamless Authentication**
- Automatically handles Google OAuth flow without manual intervention
- Supports specific user account selection via multiple configuration methods
- Remembers your preferred account across sessions

### 8.2. 🌐 **Smart Browser Management**
- Uses Chrome for Testing to avoid conflicts with your regular browser
- Automatically installs Chrome for Testing if needed
- Temporarily switches default browser for OAuth, then restores it

### 8.3. 🔄 **Rate Limit Handling**
- Detects API rate limits in real-time
- Automatically retries with `gemini-2.5-flash` model when rate limited
- Graceful failure handling with informative error messages

### 8.4. 📊 **Clean Response Extraction**
- Filters out authentication noise from gemini CLI output
- Returns clean model responses for programmatic use
- Preserves original CLI behavior for interactive use

## 9. Installation & Requirements

### 9.1. Prerequisites

**macOS only** - This tool requires macOS (Darwin) due to browser management dependencies.

#### 9.1.1. Install required tools:
```bash
# Install macdefaultbrowser utility
brew install macdefaultbrowser

# Install Playwright browsers (one-time setup)
playwright install chromium
```

#### 9.1.2. Dependencies (auto-installed via uv):
- `fire>=0.5.0` - CLI interface
- `playwright>=1.43.0` - Browser automation
- `requests>=2.31.0` - HTTP requests
- `platformdirs>=4.0.0` - Cross-platform directories
- `loguru>=0.7.0` - Logging

## 10. Usage

### 10.1. CLI Interface (Direct Replacement)

Use exactly like the regular `gemini` CLI, but with automatic OAuth:

```bash
# Ask a question
./gemini_wrapper.py -p "Explain Python decorators"

# Use specific model
./gemini_wrapper.py -m "gemini-pro" -p "Write a Python function"

# With verbose logging
./gemini_wrapper.py --verbose -p "Hello world"

# Quit Chrome when done
./gemini_wrapper.py --quit-chrome -p "What's the weather?"
```

### 10.2. Programmatic Interface

```python
from gemini_wrapper import ask

# Simple question-answer
response = ask("Explain quantum computing in simple terms")
print(response)

# With specific user account
response = ask("Generate Python code", user="myemail@gmail.com")
print(response)

# With debug logging
response = ask("Help with debugging", verbose=True)
print(response)
```

### 10.3. Advanced Usage

```python
import asyncio
from gemini_wrapper import call_gemini_cli

# Full control over gemini arguments
response = await call_gemini_cli(
    gemini_args=["-m", "gemini-pro", "-p", "Your prompt here"],
    user="specific@email.com",
    verbose=True,
    quit_chrome=True
)
```

## 11. User Account Configuration

The wrapper resolves your Google account in this priority order:

1. **`--user` CLI argument**: `./gemini_wrapper.py --user="you@gmail.com" -p "Hello"`
2. **`GEMINI_CLI_USER` environment variable**: `export GEMINI_CLI_USER="you@gmail.com"`
3. **Stored in settings.json**: Automatically saved from previous successful authentications
4. **First available account**: If none specified, uses the first Google account found

## 12. How It Works

### 12.1. Browser Automation Flow

1. **Setup Phase**:
   - Checks if Chrome for Testing is installed, installs if needed
   - Saves current default browser
   - Sets Chrome for Testing as temporary default

2. **Authentication Phase**:
   - Launches Chrome in debugging mode (port 9222)
   - Starts `gemini` CLI which opens OAuth URL in Chrome
   - Playwright connects to Chrome via Chrome DevTools Protocol (CDP)
   - Automatically clicks your account and "Sign in" button

3. **Execution Phase**:
   - Waits for OAuth success redirect
   - Monitors gemini process for completion or rate limits
   - Extracts clean response from mixed CLI output

4. **Cleanup Phase**:
   - Restores original default browser
   - Optionally quits Chrome for Testing
   - Returns clean response text

### 12.2. Rate Limit Handling

When the original request hits rate limits:
```
gemini-wrapper detects: "429" or "Quota exceeded" or "rateLimitExceeded"
↓
Automatically retries with: gemini -m "gemini-2.5-flash" [your-args]
↓
Returns response or fails gracefully
```

## 13. Old File Structure

```
work/
├── gemini_wrapper.py          # Main automation script
└── settings.json              # Auto-generated settings (Chrome path, user email)
```

## 14. Settings Storage

Settings are automatically stored in:
- **Path**: `~/Library/Application Support/com.twardoch.chrometesting/settings.json`
- **Contents**: Chrome for Testing executable path, preferred user email
- **Auto-managed**: No manual editing required

## 15. Troubleshooting

### 15.1. Common Issues

**"Chrome CDP did not become available"**
- Another Chrome instance may be running without `--remote-debugging-port`
- Check if port 9222 is blocked: `curl http://localhost:9222/json/version`
- Look at debug logs: `/tmp/gemini_chrome_stderr.log`

**"macdefaultbrowser utility missing"**
```bash
brew install macdefaultbrowser
```

**Authentication fails**
- Enable verbose mode: `--verbose` to see detailed OAuth flow
- Check screenshots saved to: `oauth_error*.png`
- Verify your Google account has access to Gemini

**Rate limits persist**
- The wrapper automatically tries `gemini-2.5-flash` on rate limits
- Wait a few minutes before retrying
- Check your Gemini API quota in Google Cloud Console

### 15.2. Debug Mode

Enable verbose logging to see the full automation process:

```bash
./gemini_wrapper.py --verbose -p "Your question"
```

This shows:
- Chrome installation and launch details
- Browser switching operations  
- OAuth flow step-by-step
- Gemini CLI output parsing
- Error details and screenshots

## 16. Security Notes

- **Browser isolation**: Uses Chrome for Testing, separate from your regular Chrome
- **Temporary access**: Only switches default browser during authentication
- **Local automation**: All OAuth automation happens locally via CDP
- **No credential storage**: No passwords or tokens are stored, only email preference

The wrapper provides a seamless, secure way to use Google's Gemini CLI without manual OAuth interruptions.

We need to port this code into `src/geminpy/` and suitably refactor it.


Be creative, diligent, critical, relentless & funny!
</file>

</files>
